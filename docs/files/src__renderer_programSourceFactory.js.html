<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/_renderer/programSourceFactory.js - xeogl</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link href='https://fonts.googleapis.com/css?family=Exo+2:400,800,900,700,600,500|Roboto:100,300,400,500,700,900'  rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">

                <h1 class="projectTitle"><a href="../../">xeogl</a> / <a href="../../docs">API Docs</a></h1>

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AABBGeometry.html">AABBGeometry</a></li>
                                <li><a href="../classes/AABBHelper.html">AABBHelper</a></li>
                                <li><a href="../classes/AmbientLight.html">AmbientLight</a></li>
                                <li><a href="../classes/Annotation.html">Annotation</a></li>
                                <li><a href="../classes/AnnotationStory.html">AnnotationStory</a></li>
                                <li><a href="../classes/AxisHelper.html">AxisHelper</a></li>
                                <li><a href="../classes/Boundary2D.html">Boundary2D</a></li>
                                <li><a href="../classes/Boundary3D.html">Boundary3D</a></li>
                                <li><a href="../classes/BoxGeometry.html">BoxGeometry</a></li>
                                <li><a href="../classes/BuildableModel.html">BuildableModel</a></li>
                                <li><a href="../classes/Camera.html">Camera</a></li>
                                <li><a href="../classes/CameraControl.html">CameraControl</a></li>
                                <li><a href="../classes/CameraController.html">CameraController</a></li>
                                <li><a href="../classes/CameraFlightAnimation.html">CameraFlightAnimation</a></li>
                                <li><a href="../classes/CameraFollowAnimation.html">CameraFollowAnimation</a></li>
                                <li><a href="../classes/CameraPath.html">CameraPath</a></li>
                                <li><a href="../classes/CameraPathAnimation.html">CameraPathAnimation</a></li>
                                <li><a href="../classes/Canvas.html">Canvas</a></li>
                                <li><a href="../classes/CardboardEffect.html">CardboardEffect</a></li>
                                <li><a href="../classes/Clip.html">Clip</a></li>
                                <li><a href="../classes/ClipHelper.html">ClipHelper</a></li>
                                <li><a href="../classes/Clips.html">Clips</a></li>
                                <li><a href="../classes/Component.html">Component</a></li>
                                <li><a href="../classes/Configs.html">Configs</a></li>
                                <li><a href="../classes/CubeTexture.html">CubeTexture</a></li>
                                <li><a href="../classes/CubicBezierCurve.html">CubicBezierCurve</a></li>
                                <li><a href="../classes/Curve.html">Curve</a></li>
                                <li><a href="../classes/CylinderGeometry.html">CylinderGeometry</a></li>
                                <li><a href="../classes/DirLight.html">DirLight</a></li>
                                <li><a href="../classes/Entity.html">Entity</a></li>
                                <li><a href="../classes/Fog.html">Fog</a></li>
                                <li><a href="../classes/Fresnel.html">Fresnel</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/Geometry.html">Geometry</a></li>
                                <li><a href="../classes/GeometryBuilder.html">GeometryBuilder</a></li>
                                <li><a href="../classes/GLTFModel.html">GLTFModel</a></li>
                                <li><a href="../classes/HeightmapGeometry.html">HeightmapGeometry</a></li>
                                <li><a href="../classes/Input.html">Input</a></li>
                                <li><a href="../classes/InputControl.html">InputControl</a></li>
                                <li><a href="../classes/LabelHelper.html">LabelHelper</a></li>
                                <li><a href="../classes/Lights.html">Lights</a></li>
                                <li><a href="../classes/Lookat.html">Lookat</a></li>
                                <li><a href="../classes/Material.html">Material</a></li>
                                <li><a href="../classes/MetallicMaterial.html">MetallicMaterial</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/MousePickControl.html">MousePickControl</a></li>
                                <li><a href="../classes/Nintendo3DSGeometry.html">Nintendo3DSGeometry</a></li>
                                <li><a href="../classes/OBBGeometry.html">OBBGeometry</a></li>
                                <li><a href="../classes/OBBHelper.html">OBBHelper</a></li>
                                <li><a href="../classes/OBJGeometry.html">OBJGeometry</a></li>
                                <li><a href="../classes/OBJModel.html">OBJModel</a></li>
                                <li><a href="../classes/Ortho.html">Ortho</a></li>
                                <li><a href="../classes/Outline.html">Outline</a></li>
                                <li><a href="../classes/Path.html">Path</a></li>
                                <li><a href="../classes/PathGeometry.html">PathGeometry</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/PhongMaterial.html">PhongMaterial</a></li>
                                <li><a href="../classes/Pin.html">Pin</a></li>
                                <li><a href="../classes/PlaneGeometry.html">PlaneGeometry</a></li>
                                <li><a href="../classes/PlaneHelper.html">PlaneHelper</a></li>
                                <li><a href="../classes/PointLight.html">PointLight</a></li>
                                <li><a href="../classes/PointLightHelper.html">PointLightHelper</a></li>
                                <li><a href="../classes/PointMarkings.html">PointMarkings</a></li>
                                <li><a href="../classes/QuadraticBezierCurve.html">QuadraticBezierCurve</a></li>
                                <li><a href="../classes/Quaternion.html">Quaternion</a></li>
                                <li><a href="../classes/Region.html">Region</a></li>
                                <li><a href="../classes/Rotate.html">Rotate</a></li>
                                <li><a href="../classes/Ruler.html">Ruler</a></li>
                                <li><a href="../classes/Scale.html">Scale</a></li>
                                <li><a href="../classes/Scene.html">Scene</a></li>
                                <li><a href="../classes/SceneJSModel.html">SceneJSModel</a></li>
                                <li><a href="../classes/Shadow.html">Shadow</a></li>
                                <li><a href="../classes/Skybox.html">Skybox</a></li>
                                <li><a href="../classes/SpecularMaterial.html">SpecularMaterial</a></li>
                                <li><a href="../classes/SphereGeometry.html">SphereGeometry</a></li>
                                <li><a href="../classes/Spinner.html">Spinner</a></li>
                                <li><a href="../classes/SplineCurve.html">SplineCurve</a></li>
                                <li><a href="../classes/SplineCurveHelper.html">SplineCurveHelper</a></li>
                                <li><a href="../classes/SpotLight.html">SpotLight</a></li>
                                <li><a href="../classes/StereoEffect.html">StereoEffect</a></li>
                                <li><a href="../classes/Story.html">Story</a></li>
                                <li><a href="../classes/TeapotGeometry.html">TeapotGeometry</a></li>
                                <li><a href="../classes/Texture.html">Texture</a></li>
                                <li><a href="../classes/TorusGeometry.html">TorusGeometry</a></li>
                                <li><a href="../classes/Transform.html">Transform</a></li>
                                <li><a href="../classes/Translate.html">Translate</a></li>
                                <li><a href="../classes/VectorTextGeometry.html">VectorTextGeometry</a></li>
                                <li><a href="../classes/ViewCube.html">ViewCube</a></li>
                                <li><a href="../classes/Viewport.html">Viewport</a></li>
                                <li><a href="../classes/xeogl.html">xeogl</a></li>
                                <li><a href="../classes/xeogl.math.math.html">xeogl.math.math</a></li>
                                <li><a href="../classes/XRay.html">XRay</a></li>
                                <li><a href="../classes/ZSpaceEffect.html">ZSpaceEffect</a></li>
                                <li><a href="../classes/ZSpaceStylusControl.html">ZSpaceStylusControl</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="..//modules/animation.html">animation</a></li>
                                <li><a href="..//modules/annotations.html">annotations</a></li>
                                <li><a href="..//modules/boundaries.html">boundaries</a></li>
                                <li><a href="..//modules/camera.html">camera</a></li>
                                <li><a href="..//modules/canvas.html">canvas</a></li>
                                <li><a href="..//modules/clipping.html">clipping</a></li>
                                <li><a href="..//modules/configs.html">configs</a></li>
                                <li><a href="..//modules/controls.html">controls</a></li>
                                <li><a href="..//modules/curves.html">curves</a></li>
                                <li><a href="..//modules/effects.html">effects</a></li>
                                <li><a href="..//modules/emphasis.html">emphasis</a></li>
                                <li><a href="..//modules/entities.html">entities</a></li>
                                <li><a href="..//modules/generation.html">generation</a></li>
                                <li><a href="..//modules/geometry.html">geometry</a></li>
                                <li><a href="..//modules/helpers.html">helpers</a></li>
                                <li><a href="..//modules/input.html">input</a></li>
                                <li><a href="..//modules/interaction.html">interaction</a></li>
                                <li><a href="..//modules/lighting.html">lighting</a></li>
                                <li><a href="..//modules/marking.html">marking</a></li>
                                <li><a href="..//modules/materials.html">materials</a></li>
                                <li><a href="..//modules/math.html">math</a></li>
                                <li><a href="..//modules/models.html">models</a></li>
                                <li><a href="..//modules/outline.html">outline</a></li>
                                <li><a href="..//modules/rendering.html">rendering</a></li>
                                <li><a href="..//modules/skyboxes.html">skyboxes</a></li>
                                <li><a href="..//modules/stories.html">stories</a></li>
                                <li><a href="..//modules/transforms.html">transforms</a></li>
                                <li><a href="..//modules/xeogl.html">xeogl</a></li>
                                <li><a href="..//modules/zspace.html">zspace</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <!--<div id="api-options">-->
                    <!--Show:-->
                    <!--<label for="api-show-inherited">-->
                        <!--<input type="checkbox" id="api-show-inherited" checked>-->
                        <!--Inherited-->
                    <!--</label>-->
            
                    <!--<label for="api-show-protected">-->
                        <!--<input type="checkbox" id="api-show-protected">-->
                        <!--Protected-->
                    <!--</label>-->
            
                    <!--<label for="api-show-private">-->
                        <!--<input type="checkbox" id="api-show-private">-->
                        <!--Private-->
                    <!--</label>-->
                    <!--<label for="api-show-deprecated">-->
                        <!--<input type="checkbox" id="api-show-deprecated">-->
                        <!--Deprecated-->
                    <!--</label>-->
            
                <!--</div>-->
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/_renderer/programSourceFactory.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function () {

    &quot;use strict&quot;;

    /**
     *  Manages creation, sharing and recycle of {@link xeogl.renderer.ProgramSource} instances
     */
    xeogl.renderer.ProgramSourceFactory = new (function () {

        var cache = {}; // Caches source code against hashes

        var src = &quot;&quot;; // Accumulates source code as it&#x27;s being built

        var states; // Cache rendering state
        var phongMaterial;
        var MetallicMaterial;
        var SpecularMaterial;
        var texturing; // True when rendering state contains textures
        var normals; // True when rendering state contains normals
        var normalMapping; // True when rendering state contains tangents
        var reflection; // True when rendering state contains reflections
        var diffuseFresnel;
        var specularFresnel;
        var alphaFresnel;
        var reflectivityFresnel;
        var emissiveFresnel;
        var receiveShadow;
        var clipping;

        /**
         * Get source code for a program to render the given states.
         * Attempts to reuse cached source code for the given hash.
         */
        this.getSource = function (hash, _states) {

            var source = cache[hash];

            if (source) {
                source.useCount++;
                return source;
            }

            states = _states;

            texturing = hasTextures();
            normals = hasNormals();
            normalMapping = hasNormalMap();
            clipping = states.clips.clips.length &gt; 0;
            phongMaterial = (states.material.type === &quot;phongMaterial&quot;);
            MetallicMaterial = (states.material.type === &quot;MetallicMaterial&quot;);
            SpecularMaterial = (states.material.type === &quot;SpecularMaterial&quot;);
            reflection = hasReflection();
            diffuseFresnel = states.material.diffuseFresnel;
            specularFresnel = states.material.specularFresnel;
            alphaFresnel = states.material.alphaFresnel;
            reflectivityFresnel = states.material.reflectivityFresnel;
            emissiveFresnel = states.material.emissiveFresnel;
            receiveShadow = receivesShadow();

            source = new xeogl.renderer.ProgramSource(
                hash,
                vertexPickObject(),
                fragmentPickObject(),
                vertexPickPrimitive(),
                fragmentPickPrimitive(),
                vertexDraw(),
                fragmentDraw(),
                vertexShadow(),
                fragmentShadow(),
                vertexOutline(),
                fragmentOutline()
            );

            cache[hash] = source;

            return source;
        };

        function receivesShadow() {
            if (!states.modes.receiveShadow) {
                return false;
            }
            var lights = states.lights.lights;
            if (!lights) {
                return false;
            }
            for (var i = 0, len = lights.length; i &lt; len; i++) {
                if (lights[i].shadow) {
                    return true;
                }
            }
            return false;
        }

        function hasTextures() {
            if (!states.geometry.uv) {
                return false;
            }
            var material = states.material;
            return material.ambientMap ||
                material.occlusionMap ||
                material.baseColorMap ||
                material.diffuseMap ||
                material.alphaMap ||
                material.specularMap ||
                material.glossinessMap ||
                material.specularGlossinessMap ||
                material.emissiveMap ||
                material.metallicMap ||
                material.roughnessMap ||
                material.metallicRoughnessMap ||
                material.reflectivityMap ||
                states.material.normalMap;
        }

        function hasReflection() {
            return false;
            //return (states.cubemap.layers &amp;&amp; states.cubemap.layers.length &gt; 0 &amp;&amp; states.geometry.normalBuf);
        }

        function hasNormals() {
            var primitive = states.geometry.primitiveName;
            if ((states.geometry.autoNormals || states.geometry.normals) &amp;&amp; (primitive === &quot;triangles&quot; || primitive === &quot;triangle-strip&quot; || primitive === &quot;triangle-fan&quot;)) {
                return true;
            }
            return false;
        }

        function hasNormalMap() {
            var geometry = states.geometry;
            return (geometry.positions &amp;&amp; geometry.indices &amp;&amp; geometry.normals &amp;&amp; geometry.uv &amp;&amp; states.material.normalMap);
        }

        /**
         * Releases program source code back to this factory.
         */
        this.putSource = function (hash) {
            var source = cache[hash];
            if (source) {
                if (--source.useCount === 0) {
                    cache[source.hash] = null;
                }
            }
        };


        // NOTE: Picking shaders will become more complex and will eventually be
        // composed from state, in the same manner as the draw shaders.

        function vertexPickObject() {
            begin();
            add(&quot;// Object picking vertex shader&quot;);
            add(&quot;attribute vec3 position;&quot;);
            add(&quot;uniform mat4 modelMatrix;&quot;);
            add(&quot;uniform mat4 viewMatrix;&quot;);
            add(&quot;uniform mat4 viewNormalMatrix;&quot;);
            add(&quot;uniform mat4 projMatrix;&quot;);
            add(&quot;varying vec4 vViewPosition;&quot;);
            if (clipping) {
                add(&quot;varying vec4 vWorldPosition;&quot;);
            }
            add(&quot;void main(void) {&quot;);
            add(&quot;   vec4 tmpVertex = vec4(position, 1.0); &quot;);
            add(&quot;   vec4 worldPosition = modelMatrix * tmpVertex;&quot;);
            add(&quot;   vViewPosition = viewMatrix * worldPosition;&quot;);
            if (clipping) {
                add(&quot;   vWorldPosition = worldPosition;&quot;);
            }
            add(&quot;   gl_Position = projMatrix * vViewPosition;&quot;);
            add(&quot;}&quot;);
            return end();
        }

        function fragmentPickObject() {
            begin();
            add(&quot;// Object picking fragment shader&quot;);
            add(&quot;precision &quot; + getFSFloatPrecision(states.gl) + &quot; float;&quot;);
            add(&quot;uniform vec4 pickColor;&quot;);
            if (clipping) {
                add(&quot;uniform bool clippable;&quot;);
                add(&quot;varying vec4 vWorldPosition;&quot;);
                for (var i = 0; i &lt; states.clips.clips.length; i++) {
                    add(&quot;uniform bool clipActive&quot; + i + &quot;;&quot;);
                    add(&quot;uniform vec3 clipPos&quot; + i + &quot;;&quot;);
                    add(&quot;uniform vec3 clipDir&quot; + i + &quot;;&quot;);
                }
            }
            add(&quot;void main(void) {&quot;);
            if (clipping) {
                add(&quot;if (clippable) {&quot;);
                add(&quot;  float dist = 0.0;&quot;);
                for (var i = 0; i &lt; states.clips.clips.length; i++) {
                    add(&quot;if (clipActive&quot; + i + &quot;) {&quot;);
                    add(&quot;   dist += clamp(dot(-clipDir&quot; + i + &quot;.xyz, vWorldPosition.xyz - clipPos&quot; + i + &quot;.xyz), 0.0, 1000.0);&quot;);
                    add(&quot;}&quot;);
                }
                add(&quot;  if (dist &gt; 0.0) { discard; }&quot;);
                add(&quot;}&quot;);
            }
            add(&quot;   gl_FragColor = pickColor; &quot;);
            add(&quot;}&quot;);
            return end();
        }

        function vertexPickPrimitive() {
            begin();
            add(&quot;// Triangle picking vertex shader&quot;);
            add(&quot;attribute vec3 position;&quot;);
            add(&quot;attribute vec4 color;&quot;);
            add(&quot;uniform vec3 pickColor;&quot;);
            add(&quot;uniform mat4 modelMatrix;&quot;);
            add(&quot;uniform mat4 viewMatrix;&quot;);
            add(&quot;uniform mat4 projMatrix;&quot;);
            add(&quot;varying vec4 vViewPosition;&quot;);
            add(&quot;varying vec4 vColor;&quot;);
            if (clipping) {
                add(&quot;varying vec4 vWorldPosition;&quot;);
            }
            add(&quot;void main(void) {&quot;);
            add(&quot;   vec4 tmpVertex = vec4(position, 1.0); &quot;);
            add(&quot;   vec4 worldPosition = modelMatrix * tmpVertex; &quot;);
            add(&quot;   vec4 viewPosition = viewMatrix * worldPosition;&quot;);
            if (clipping) {
                add(&quot;   vWorldPosition = worldPosition;&quot;);
            }
            add(&quot;   vColor = color;&quot;);
            add(&quot;   gl_Position = projMatrix * viewPosition;&quot;);
            add(&quot;}&quot;);

            return end();
        }

        function fragmentPickPrimitive() {
            begin();
            add(&quot;// Triangle picking fragment shader&quot;);
            add(&quot;precision &quot; + getFSFloatPrecision(states.gl) + &quot; float;&quot;);
            add(&quot;varying vec4 vColor;&quot;);
            if (clipping) {
                add(&quot;uniform bool clippable;&quot;);
                add(&quot;varying vec4 vWorldPosition;&quot;);
                for (var i = 0; i &lt; states.clips.clips.length; i++) {
                    add(&quot;uniform bool clipActive&quot; + i + &quot;;&quot;);
                    add(&quot;uniform vec3 clipPos&quot; + i + &quot;;&quot;);
                    add(&quot;uniform vec3 clipDir&quot; + i + &quot;;&quot;);
                }
            }
            add(&quot;void main(void) {&quot;);
            if (clipping) {
                add(&quot;if (clippable) {&quot;);
                add(&quot;  float dist = 0.0;&quot;);
                for (var i = 0; i &lt; states.clips.clips.length; i++) {
                    add(&quot;if (clipActive&quot; + i + &quot;) {&quot;);
                    add(&quot;   dist += clamp(dot(-clipDir&quot; + i + &quot;.xyz, vWorldPosition.xyz - clipPos&quot; + i + &quot;.xyz), 0.0, 1000.0);&quot;);
                    add(&quot;}&quot;);
                }
                add(&quot;  if (dist &gt; 0.0) { discard; }&quot;);
                add(&quot;}&quot;);
            }
            add(&quot;   gl_FragColor = vColor;&quot;);
            add(&quot;}&quot;);
            return end();
        }

        /// NOTE: Shadow shaders will become more complex and will eventually be
        // composed from state, in the same manner as the draw shaders.

        function vertexShadow() {
            begin();
            add(&quot;// Shadow map vertex shader&quot;);
            add(&quot;attribute vec3 position;&quot;);
            add(&quot;uniform mat4 modelMatrix;&quot;);
            add(&quot;uniform mat4 shadowViewMatrix;&quot;);
            add(&quot;uniform mat4 shadowProjMatrix;&quot;);
            if (clipping) {
                add(&quot;varying vec4 vWorldPosition;&quot;);
            }
            add(&quot;void main(void) {&quot;);
            add(&quot;   vec4 worldPosition = modelMatrix * (vec4(position, 1.0));&quot;);
            if (clipping) {
                add(&quot;   vWorldPosition = worldPosition;&quot;);
            }
            add(&quot;   gl_Position = shadowProjMatrix * (shadowViewMatrix * (worldPosition));&quot;);
            add(&quot;}&quot;);
            return end();
        }

        function fragmentShadow() {
            begin();
            add(&quot;// Shadow map fragment shader&quot;);
            add(&quot;precision &quot; + getFSFloatPrecision(states.gl) + &quot; float;&quot;);
            if (clipping) {
                add(&quot;varying vec4 vWorldPosition;&quot;);
                add(&quot;uniform bool clippable;&quot;);
                for (var i = 0; i &lt; states.clips.clips.length; i++) {
                    add(&quot;uniform bool clipActive&quot; + i + &quot;;&quot;);
                    add(&quot;uniform vec3 clipPos&quot; + i + &quot;;&quot;);
                    add(&quot;uniform vec3 clipDir&quot; + i + &quot;;&quot;);
                }
            }
            add(&quot;void main(void) {&quot;);
            if (clipping) {
                add(&quot;if (clippable) {&quot;);
                add(&quot;  float dist = 0.0;&quot;);
                for (var i = 0; i &lt; states.clips.clips.length; i++) {
                    add(&quot;if (clipActive&quot; + i + &quot;) {&quot;);
                    add(&quot;   dist += clamp(dot(-clipDir&quot; + i + &quot;.xyz, vWorldPosition.xyz - clipPos&quot; + i + &quot;.xyz), 0.0, 1000.0);&quot;);
                    add(&quot;}&quot;);
                }
                add(&quot;  if (dist &gt; 0.0) { discard; }&quot;);
                add(&quot;}&quot;);
            }
            add(&quot;   gl_FragColor = vec4(gl_FragCoord.z, 0.0, 0.0, 0.0);&quot;);
            add(&quot;}&quot;);
            return end();
        }

        function vertexOutline() {
            begin();
            add(&quot;attribute vec4 position;&quot;);
            add(&quot;uniform mat4 modelMatrix;&quot;);
            add(&quot;uniform mat4 viewMatrix;&quot;);
            add(&quot;uniform mat4 projMatrix;&quot;);
            add(&quot;uniform float thickness;&quot;);
            if (normals) {
                add(&quot;attribute vec3 normal;&quot;);
            }
            var billboard = states.modes.billboard;
            if (billboard === &quot;spherical&quot; || billboard === &quot;cylindrical&quot;) {
                add(&quot;void billboard(inout mat4 mat) {&quot;);
                add(&quot;   mat[0][0] = 1.0;&quot;);
                add(&quot;   mat[0][1] = 0.0;&quot;);
                add(&quot;   mat[0][2] = 0.0;&quot;);
                if (billboard === &quot;spherical&quot;) {
                    add(&quot;   mat[1][0] = 0.0;&quot;);
                    add(&quot;   mat[1][1] = 1.0;&quot;);
                    add(&quot;   mat[1][2] = 0.0;&quot;);
                }
                add(&quot;   mat[2][0] = 0.0;&quot;);
                add(&quot;   mat[2][1] = 0.0;&quot;);
                add(&quot;   mat[2][2] =1.0;&quot;);
                add(&quot;}&quot;);
            }
            if (clipping) {
                add(&quot;varying vec4 vWorldPosition;&quot;);
            }
            add(&quot;void main(void) {&quot;);
            add(&quot;mat4 viewMatrix2 = viewMatrix;&quot;);
            add(&quot;mat4 modelMatrix2 = modelMatrix;&quot;);
            if (states.modes.stationary) {
                add(&quot;viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;&quot;)
            }
            if (billboard === &quot;spherical&quot; || billboard === &quot;cylindrical&quot;) {
                add(&quot;billboard(modelMatrix2);&quot;);
                add(&quot;billboard(viewMatrix2);&quot;);
            }
            // Displacement
            if (normals) {
                add(&quot;vec4 projPos = projMatrix * viewMatrix2 * modelMatrix2 * vec4(position.xyz, 1.0); &quot;);
                add(&quot;  vec3 offset = (normalize(normal) * (thickness * 0.0005 * (projPos.z/1.0)));&quot;);
            } else {
                add(&quot;  vec3 offset = vec3(0.0, 0.0, 0.0);&quot;);
            }
            add(&quot;vec4 worldPosition = modelMatrix * vec4(position.xyz + offset, 1.0); &quot;);
            if (clipping) {
                add(&quot;   vWorldPosition = worldPosition;&quot;);
            }
            add(&quot;  gl_Position = projMatrix * (viewMatrix * worldPosition);&quot;);
            add(&quot;}&quot;);
            return end();
        }

        function fragmentOutline() {
            begin();
            add(&quot;precision &quot; + getFSFloatPrecision(states.gl) + &quot; float;&quot;);
            add(&quot;uniform vec3  color;&quot;);
            if (clipping) {
                add(&quot;uniform bool clippable;&quot;);
                add(&quot;varying vec4 vWorldPosition;&quot;);
                for (var i = 0; i &lt; states.clips.clips.length; i++) {
                    add(&quot;uniform bool clipActive&quot; + i + &quot;;&quot;);
                    add(&quot;uniform vec3 clipPos&quot; + i + &quot;;&quot;);
                    add(&quot;uniform vec3 clipDir&quot; + i + &quot;;&quot;);
                }
            }
            add(&quot;void main(void) {&quot;);
            if (clipping) {
                add(&quot;if (clippable) {&quot;);
                add(&quot;  float dist = 0.0;&quot;);
                for (var i = 0; i &lt; states.clips.clips.length; i++) {
                    add(&quot;if (clipActive&quot; + i + &quot;) {&quot;);
                    add(&quot;   dist += clamp(dot(-clipDir&quot; + i + &quot;.xyz, vWorldPosition.xyz - clipPos&quot; + i + &quot;.xyz), 0.0, 1000.0);&quot;);
                    add(&quot;}&quot;);
                }
                add(&quot;  if (dist &gt; 0.0) { discard; }&quot;);
                add(&quot;}&quot;);
            }
            add(&quot;   gl_FragColor = vec4(color, 1.0);&quot;);
            add(&quot;}&quot;);
            return end();
        }

        function vertexDraw() {

            var i;
            var len;
            var lights = states.lights.lights;
            var light;

            begin();

            add(&quot;// Drawing vertex shader&quot;);
            add(&quot;attribute  vec3 position;&quot;);

            add(&quot;uniform    mat4 modelMatrix;&quot;);
            add(&quot;uniform    mat4 viewMatrix;&quot;);
            add(&quot;uniform    mat4 projMatrix;&quot;);

            add(&quot;varying    vec3 vViewPosition;&quot;);

            if (clipping) {
                add(&quot;varying vec4 vWorldPosition;&quot;);
            }

            if (states.lights.lightMap) {
                add(&quot;varying    vec3 vWorldNormal;&quot;);
            }

            if (normals) {

                add(&quot;attribute  vec3 normal;&quot;);

                add(&quot;uniform    mat4 modelNormalMatrix;&quot;);
                add(&quot;uniform    mat4 viewNormalMatrix;&quot;);

                add(&quot;varying    vec3 vViewNormal;&quot;);

                if (states.material.normalMap) {
                    add(&quot;varying    mat3 vTBN;&quot;);
                }

                for (i = 0, len = states.lights.lights.length; i &lt; len; i++) {

                    light = states.lights.lights[i];

                    if (light.type === &quot;ambient&quot;) {
                        continue;
                    }

                    if (light.type === &quot;dir&quot;) {
                        add(&quot;uniform vec3 lightDir&quot; + i + &quot;;&quot;);
                    }

                    if (light.type === &quot;point&quot;) {
                        add(&quot;uniform vec3 lightPos&quot; + i + &quot;;&quot;);
                    }

                    if (light.type === &quot;spot&quot;) {
                        add(&quot;uniform vec3 lightPos&quot; + i + &quot;;&quot;);
                    }

                    if (!(light.type === &quot;dir&quot; &amp;&amp; light.space === &quot;view&quot;)) {
                        // World-space dir lights don&#x27;t need these varyings
                        add(&quot;varying vec4 vViewLightReverseDirAndDist&quot; + i + &quot;;&quot;);
                    }
                }
            }

            if (normalMapping) {
                add(&quot;attribute vec3 tangent;&quot;);
            }

            if (texturing) {
                add(&quot;attribute vec2 uv;&quot;);
                add(&quot;varying vec2 vUV;&quot;);
            }

            if (states.geometry.colors) {
                add(&quot;attribute vec4 color;&quot;);
                add(&quot;varying vec4 vColor;&quot;);
            }

            if (states.geometry.primitiveName === &quot;points&quot;) {
                add(&quot;uniform float pointSize;&quot;);
            }

            var billboard = states.modes.billboard;

            if (billboard === &quot;spherical&quot; || billboard === &quot;cylindrical&quot;) {

                add(&quot;void billboard(inout mat4 mat) {&quot;);
                add(&quot;   mat[0][0] = 1.0;&quot;);
                add(&quot;   mat[0][1] = 0.0;&quot;);
                add(&quot;   mat[0][2] = 0.0;&quot;);

                if (billboard === &quot;spherical&quot;) {
                    add(&quot;   mat[1][0] = 0.0;&quot;);
                    add(&quot;   mat[1][1] = 1.0;&quot;);
                    add(&quot;   mat[1][2] = 0.0;&quot;);
                }

                add(&quot;   mat[2][0] = 0.0;&quot;);
                add(&quot;   mat[2][1] = 0.0;&quot;);
                add(&quot;   mat[2][2] =1.0;&quot;);
                add(&quot;}&quot;);
            }

            if (receiveShadow) {
                for (i = 0, len = lights.length; i &lt; len; i++) { // Light sources
                    if (lights[i].shadow) {
                        add(&quot;uniform mat4 shadowViewMatrix&quot; + i + &quot;;&quot;);
                        add(&quot;uniform mat4 shadowProjMatrix&quot; + i + &quot;;&quot;);
                        add(&quot;varying vec4 vShadowPosFromLight&quot; + i + &quot;;&quot;);
                    }
                }
            }

            add(&quot;void main(void) {&quot;);

            add(&quot;vec4 localPosition = vec4(position, 1.0); &quot;);
            add(&quot;vec4 worldPosition;&quot;);

            if (normals) {
                add(&quot;vec4 localNormal = vec4(normal, 0.0); &quot;);
                add(&quot;mat4 modelNormalMatrix2    = modelNormalMatrix;&quot;);
                add(&quot;mat4 viewNormalMatrix2     = viewNormalMatrix;&quot;);

            }

            add(&quot;mat4 viewMatrix2           = viewMatrix;&quot;);
            add(&quot;mat4 modelMatrix2          = modelMatrix;&quot;);

            if (states.modes.stationary) {
                add(&quot;viewMatrix2[3][0] = viewMatrix2[3][1] = viewMatrix2[3][2] = 0.0;&quot;)
            }

            if (billboard === &quot;spherical&quot; || billboard === &quot;cylindrical&quot;) {

                add(&quot;mat4 modelViewMatrix = viewMatrix2 * modelMatrix2;&quot;);

                add(&quot;billboard(modelMatrix2);&quot;);
                add(&quot;billboard(viewMatrix2);&quot;);
                add(&quot;billboard(modelViewMatrix);&quot;);

                if (normals) {

                    add(&quot;mat4 modelViewNormalMatrix =  viewNormalMatrix2 * modelNormalMatrix2;&quot;);

                    add(&quot;billboard(modelNormalMatrix2);&quot;);
                    add(&quot;billboard(viewNormalMatrix2);&quot;);
                    add(&quot;billboard(modelViewNormalMatrix);&quot;);
                }

                add(&quot;worldPosition = modelMatrix2 * localPosition;&quot;);
                add(&quot;vec4 viewPosition = modelViewMatrix * localPosition;&quot;);

            } else {

                add(&quot;worldPosition = modelMatrix2 * localPosition;&quot;);
                add(&quot;vec4 viewPosition  = viewMatrix2 * worldPosition; &quot;);
            }

            if (normals) {

                add(&quot;vec3 worldNormal = (modelNormalMatrix2 * localNormal).xyz; &quot;);
                if (states.lights.lightMap) {
                    add(&quot;vWorldNormal = worldNormal;&quot;);
                }
                add(&quot;vViewNormal = normalize((viewNormalMatrix2 * vec4(worldNormal, 1.0)).xyz);&quot;);

                if (normalMapping) {

                    add(&quot;mat4 mat =  viewMatrix2 * modelMatrix2;&quot;);

                    add(&quot;vec3 n = normalize( ( mat * vec4( normal, 0.0 ) ).xyz );&quot;);
                    add(&quot;vec3 t = normalize( ( mat * vec4( tangent, 0.0 ) ).xyz );&quot;);
                    add(&quot;vec3 b = normalize( ( mat * vec4( ( cross(normal, tangent.xyz ) * 1.0 ), 0.0 ) ).xyz );&quot;);

                    add(&quot;vTBN = mat3(t, b, n);&quot;);
                }

                add(&quot;vec3 tmpVec3;&quot;);
                add(&quot;float lightDist;&quot;);

                for (i = 0, len = states.lights.lights.length; i &lt; len; i++) { // Lights

                    light = states.lights.lights[i];

                    if (light.type === &quot;ambient&quot;) {
                        continue;
                    }

                    if (light.type === &quot;dir&quot;) {

                        if (light.space === &quot;world&quot;) {
                            add(&quot;tmpVec3 = vec3(viewMatrix2 * vec4(lightDir&quot; + i + &quot;, 0.0) ).xyz;&quot;);
                            add(&quot;vViewLightReverseDirAndDist&quot; + i + &quot; = vec4(-tmpVec3, 0.0);&quot;);
                        }
                    }

                    if (light.type === &quot;point&quot;) {

                        if (light.space === &quot;world&quot;) {
                            add(&quot;tmpVec3 = (viewMatrix2 * vec4(lightPos&quot; + i + &quot;, 1.0)).xyz - viewPosition.xyz;&quot;);
                            add(&quot;lightDist = abs(length(tmpVec3));&quot;);

                        } else {
                            add(&quot;tmpVec3 = lightPos&quot; + i + &quot;.xyz - viewPosition.xyz;&quot;);
                            add(&quot;lightDist = abs(length(tmpVec3));&quot;);
                        }

                        add(&quot;vViewLightReverseDirAndDist&quot; + i + &quot; = vec4(tmpVec3, lightDist);&quot;);
                    }
                }
            }

            if (texturing) {
                add(&quot;vUV = uv;&quot;);
            }

            if (states.geometry.colors) {
                add(&quot;vColor = color;&quot;);
            }

            if (states.geometry.primitiveName === &quot;points&quot;) {
                add(&quot;gl_PointSize = pointSize;&quot;);
            }

            if (clipping) {
                add(&quot;vWorldPosition = worldPosition;&quot;);
            }

            add(&quot;   vViewPosition = viewPosition.xyz;&quot;);

            add(&quot;   gl_Position = projMatrix * viewPosition;&quot;);

            if (receiveShadow) {
                add(&quot;vec4 tempx; &quot;);
                for (i = 0, len = lights.length; i &lt; len; i++) { // Light sources
                    if (lights[i].shadow) {
                        add(&quot;vShadowPosFromLight&quot; + i + &quot; = shadowProjMatrix&quot; + i + &quot; * (shadowViewMatrix&quot; + i + &quot; * worldPosition); &quot;);
                        //add(&quot;tempx = shadowViewMatrix&quot; + i + &quot; * worldPosition; &quot;);
                        //add(&quot;tempx = shadowProjMatrix&quot; + i + &quot; * tempx; &quot;);
                        //add(&quot;   gl_Position = tempx;&quot;);
                    }
                }
            }

            add(&quot;}&quot;);

            return end();
        }

        function fragmentDraw() {

            var material = states.material;
            var geometry = states.geometry;

            var phongMaterial = material.type === &quot;phongMaterial&quot;;
            var pbrMetalRough = material.type === &quot;MetallicMaterial&quot;;
            var pbrSpecGloss = material.type === &quot;SpecularMaterial&quot;;

            var i;
            var len;
            var lights = states.lights.lights;
            var light;

            begin();

            add(&quot;// Drawing fragment shader&quot;);

            add(&quot;precision &quot; + getFSFloatPrecision(states.gl) + &quot; float;&quot;);

            add(&quot;vec4 LinearTosRGB( in vec4 value ) {&quot;);
            add(&quot;   return vec4(mix(pow(value.rgb,vec3(0.41666))*1.055-vec3(0.055), value.rgb*12.92, vec3(lessThanEqual(value.rgb,vec3(0.0031308)))),value.w);&quot;);
            add(&quot;}&quot;);

            //--------------------------------------------------------------------------------
            // USER CLIP PLANES
            //--------------------------------------------------------------------------------

            if (clipping) {
                add(&quot;varying vec4 vWorldPosition;&quot;);
                add(&quot;uniform bool clippable;&quot;);
                for (var i = 0; i &lt; states.clips.clips.length; i++) {
                    add(&quot;uniform bool clipActive&quot; + i + &quot;;&quot;);
                    add(&quot;uniform vec3 clipPos&quot; + i + &quot;;&quot;);
                    add(&quot;uniform vec3 clipDir&quot; + i + &quot;;&quot;);
                }
            }

            if (geometry.normals) {

                //--------------------------------------------------------------------------------
                // LIGHT AND REFLECTION MAP INPUTS
                // Define here so available globally to shader functions
                //--------------------------------------------------------------------------------

                if (states.lights.lightMap) {
                    add(&quot;uniform samplerCube lightMap;&quot;);
                    add(&quot;uniform mat4 viewNormalMatrix;&quot;);
                }

                if (states.lights.reflectionMap) {
                    add(&quot;uniform samplerCube reflectionMap;&quot;);
                }

                if (states.lights.lightMap || states.lights.reflectionMap) {
                    add(&quot;uniform mat4 viewMatrix;&quot;);
                }

                //--------------------------------------------------------------------------------
                // SHADING FUNCTIONS
                //--------------------------------------------------------------------------------

                // CONSTANT DEFINITIONS

                add(&quot;#define PI 3.14159265359&quot;);
                add(&quot;#define RECIPROCAL_PI 0.31830988618&quot;);
                add(&quot;#define RECIPROCAL_PI2 0.15915494&quot;);
                add(&quot;#define EPSILON 1e-6&quot;);

                add(&quot;#define saturate(a) clamp( a, 0.0, 1.0 )&quot;);

                // UTILITY DEFINITIONS

                add(&quot;float pow2(const in float x) {&quot;);
                add(&quot;   return x*x;&quot;);
                add(&quot;}&quot;);

                add(&quot;vec3 inverseTransformDirection(in vec3 dir, in mat4 matrix) {&quot;);
                add(&quot;   return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );&quot;);
                add(&quot;}&quot;);

                // STRUCTURES

                add(&quot;struct IncidentLight {&quot;);
                add(&quot;   vec3 color;&quot;);
                add(&quot;   vec3 direction;&quot;);
                add(&quot;};&quot;);

                add(&quot;struct ReflectedLight {&quot;);
                add(&quot;   vec3 diffuse;&quot;);
                add(&quot;   vec3 specular;&quot;);
                add(&quot;};&quot;);

                add(&quot;struct Geometry {&quot;);
                add(&quot;   vec3 position;&quot;);
                add(&quot;   vec3 viewNormal;&quot;);
                add(&quot;   vec3 worldNormal;&quot;);
                add(&quot;   vec3 viewEyeDir;&quot;);
                add(&quot;};&quot;);

                add(&quot;struct Material {&quot;);
                add(&quot;   vec3    diffuseColor;&quot;);
                add(&quot;   float   specularRoughness;&quot;);
                add(&quot;   vec3    specularColor;&quot;);
                add(&quot;   float   shine;&quot;); // Only used for Phong
                add(&quot;};&quot;);

                // DIFFUSE BRDF EVALUATION

                add(&quot;vec3 BRDF_Diffuse_Lambert(const in vec3 diffuseColor) {&quot;);
                add(&quot;   return RECIPROCAL_PI * diffuseColor;&quot;);
                add(&quot;}&quot;);

                // COMMON UTILS

                if (phongMaterial) {

                    if (states.lights.lightMap || states.lights.reflectionMap) {

                        add(&quot;void computePhongLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {&quot;);

                        if (states.lights.lightMap) {
                            add(&quot;   vec3 irradiance = textureCube(lightMap, geometry.worldNormal).rgb;&quot;);
                            add(&quot;   irradiance *= PI;&quot;);
                            add(&quot;   vec3 diffuseBRDFContrib = BRDF_Diffuse_Lambert(material.diffuseColor);&quot;);
                            add(&quot;   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;&quot;);
                        }

                        if (states.lights.reflectionMap) {
                            //     add(&quot;   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.worldNormal);&quot;);
                            //   //  add(&quot;   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);&quot;);
                            //     add(&quot;   vec3 radiance               = textureCube(reflectionMap, geometry.worldNormal).rgb;&quot;);
                            ////     add(&quot;   radiance *= PI;&quot;);
                            //     add(&quot;   reflectedLight.specular     += radiance;&quot;);
                        }

                        add(&quot;}&quot;);
                    }

                    add(&quot;void computePhongLighting(const in IncidentLight directLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {&quot;);
                    add(&quot;   float dotNL     = saturate(dot(geometry.viewNormal, directLight.direction));&quot;);
                    add(&quot;   vec3 irradiance = dotNL * directLight.color * PI;&quot;);
                    add(&quot;   reflectedLight.diffuse  += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);&quot;);
                    add(&quot;   reflectedLight.specular += directLight.color * material.specularColor * pow(max(dot(reflect(-directLight.direction, -geometry.viewNormal), geometry.viewEyeDir), 0.0), material.shine);&quot;);
                    add(&quot;}&quot;);
                }

                if (pbrMetalRough || pbrSpecGloss) {

                    // IRRADIANCE EVALUATION

                    //add(&quot;vec3 sample_reflectMapEquirect(const in vec3 reflect, const in float mipLevel) {&quot;);
                    //add(&quot;   vec2 sampleUV;&quot;);
                    //add(&quot;   sampleUV.y = saturate(reflect.y * 0.5 + 0.5);&quot;);
                    //add(&quot;   sampleUV.x = atan(reflect.z, reflect.x) * RECIPROCAL_PI2 + 0.5;&quot;);
                    //add(&quot;   vec4 texColor = texture2D(reflectionMap, sampleUV, mipLevel);&quot;);
                    //add(&quot;   return texColor.rgb;&quot;); // assumed to be linear
                    //add(&quot;}&quot;);

                    add(&quot;float GGXRoughnessToBlinnExponent(const in float ggxRoughness) {&quot;);
                    add(&quot;   return (2.0 / pow2(ggxRoughness + 0.0001) - 2.0);&quot;);
                    add(&quot;}&quot;);

                    add(&quot;float getSpecularMIPLevel(const in float blinnShininessExponent, const in int maxMIPLevel) {&quot;);
                    add(&quot;   float maxMIPLevelScalar = float( maxMIPLevel );&quot;);
                    add(&quot;   float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );&quot;);
                    add(&quot;   return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );&quot;);
                    add(&quot;}&quot;);

                    //add(&quot;vec3 getLightProbeIndirectRadiance(const in mat4 viewMatrix, const in Geometry geometry, const in float blinnShininessExponent, const in int maxMIPLevel) {&quot;);
                    //add(&quot;   vec3 reflectVec = reflect(geometry.viewEyeDir, geometry.viewNormal);&quot;);
                    //add(&quot;   reflectVec = inverseTransformDirection(reflectVec, viewMatrix);&quot;);
                    //add(&quot;   float mipLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );&quot;);
                    //add(&quot;   vec3 reflectionMapColor = sample_reflectMapEquirect(reflectVec, float(mipLevel));&quot;);
                    //add(&quot;   return reflectionMapColor;&quot;);
                    //add(&quot;}&quot;);


                    if (states.lights.reflectionMap) {
                        add(&quot;vec3 getLightProbeIndirectRadiance(const in vec3 reflectVec, const in float blinnShininessExponent, const in int maxMIPLevel) {&quot;);
                        add(&quot;   float mipLevel = 0.5 * getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);&quot;); //TODO: a random factor - fix this
                        add(&quot;   vec3 envMapColor = textureCube(reflectionMap, reflectVec, mipLevel).rgb;&quot;);
                        add(&quot;   return envMapColor;&quot;);
                        add(&quot;}&quot;);
                    }

                    // SPECULAR BRDF EVALUATION

                    add(&quot;vec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {&quot;);
                    add(&quot;   float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );&quot;);
                    add(&quot;   return ( 1.0 - specularColor ) * fresnel + specularColor;&quot;);
                    add(&quot;}&quot;);

                    add(&quot;float G_GGX_Smith(const in float alpha, const in float dotNL, const in float dotNV) {&quot;);
                    add(&quot;   float a2 = pow2( alpha );&quot;);
                    add(&quot;   float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );&quot;);
                    add(&quot;   float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );&quot;);
                    add(&quot;   return 1.0 / ( gl * gv );&quot;);
                    add(&quot;}&quot;);

                    add(&quot;float G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {&quot;);
                    add(&quot;   float a2 = pow2( alpha );&quot;);
                    add(&quot;   float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );&quot;);
                    add(&quot;   float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );&quot;);
                    add(&quot;   return 0.5 / max( gv + gl, EPSILON );&quot;);
                    add(&quot;}&quot;);

                    add(&quot;float D_GGX(const in float alpha, const in float dotNH) {&quot;);
                    add(&quot;   float a2 = pow2( alpha );&quot;);
                    add(&quot;   float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;&quot;);
                    add(&quot;   return RECIPROCAL_PI * a2 / pow2( denom );&quot;);
                    add(&quot;}&quot;);

                    add(&quot;vec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in Geometry geometry, const in vec3 specularColor, const in float roughness) {&quot;);
                    add(&quot;   float alpha = pow2( roughness );&quot;);
                    add(&quot;   vec3 halfDir = normalize( incidentLight.direction + geometry.viewEyeDir );&quot;);
                    add(&quot;   float dotNL = saturate( dot( geometry.viewNormal, incidentLight.direction ) );&quot;);
                    add(&quot;   float dotNV = saturate( dot( geometry.viewNormal, geometry.viewEyeDir ) );&quot;);
                    add(&quot;   float dotNH = saturate( dot( geometry.viewNormal, halfDir ) );&quot;);
                    add(&quot;   float dotLH = saturate( dot( incidentLight.direction, halfDir ) );&quot;);
                    add(&quot;   vec3  F = F_Schlick( specularColor, dotLH );&quot;);
                    add(&quot;   float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );&quot;);
                    add(&quot;   float D = D_GGX( alpha, dotNH );&quot;);
                    add(&quot;   return F * (G * D);&quot;);
                    add(&quot;}&quot;);

                    add(&quot;vec3 BRDF_Specular_GGX_Environment(const in Geometry geometry, const in vec3 specularColor, const in float roughness) {&quot;);
                    add(&quot;   float dotNV = saturate(dot(geometry.viewNormal, geometry.viewEyeDir));&quot;);
                    add(&quot;   const vec4 c0 = vec4( -1, -0.0275, -0.572,  0.022);&quot;);
                    add(&quot;   const vec4 c1 = vec4(  1,  0.0425,   1.04, -0.04);&quot;);
                    add(&quot;   vec4 r = roughness * c0 + c1;&quot;);
                    add(&quot;   float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;&quot;);
                    add(&quot;   vec2 AB    = vec2(-1.04, 1.04) * a004 + r.zw;&quot;);
                    add(&quot;   return specularColor * AB.x + AB.y;&quot;);
                    add(&quot;}&quot;);


                    if (states.lights.lightMap || states.lights.reflectionMap) {

                        add(&quot;void computePBRLightMapping(const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {&quot;);

                        if (states.lights.lightMap) {
                            add(&quot;   vec3 irradiance = textureCube(lightMap, geometry.worldNormal).rgb;&quot;);
                            add(&quot;   irradiance *= PI;&quot;);
                            add(&quot;   vec3 diffuseBRDFContrib = BRDF_Diffuse_Lambert(material.diffuseColor);&quot;);
                            add(&quot;   reflectedLight.diffuse += irradiance * diffuseBRDFContrib;&quot;);
                            //   add(&quot;   reflectedLight.diffuse = vec3(1.0, 0.0, 0.0);&quot;);
                        }

                        if (states.lights.reflectionMap) {
                            add(&quot;   vec3 reflectVec             = reflect(-geometry.viewEyeDir, geometry.viewNormal);&quot;);
                            add(&quot;   reflectVec                  = inverseTransformDirection(reflectVec, viewMatrix);&quot;);
                            add(&quot;   float blinnExpFromRoughness = GGXRoughnessToBlinnExponent(material.specularRoughness);&quot;);
                            add(&quot;   vec3 radiance               = getLightProbeIndirectRadiance(reflectVec, blinnExpFromRoughness, 8);&quot;);
                            add(&quot;   vec3 specularBRDFContrib    = BRDF_Specular_GGX_Environment(geometry, material.specularColor, material.specularRoughness);&quot;);
                            add(&quot;   reflectedLight.specular     += radiance * specularBRDFContrib;&quot;);
                        }

                        add(&quot;}&quot;);
                    }

                    // MAIN LIGHTING COMPUTATION FUNCTION

                    add(&quot;void computePBRLighting(const in IncidentLight incidentLight, const in Geometry geometry, const in Material material, inout ReflectedLight reflectedLight) {&quot;);
                    add(&quot;   float dotNL     = saturate(dot(geometry.viewNormal, incidentLight.direction));&quot;);
                    add(&quot;   vec3 irradiance = dotNL * incidentLight.color * PI;&quot;);
                    add(&quot;   reflectedLight.diffuse  += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);&quot;);
                    add(&quot;   reflectedLight.specular += irradiance * BRDF_Specular_GGX(incidentLight, geometry, material.specularColor, material.specularRoughness);&quot;);
                    add(&quot;}&quot;);

                } // (pbrMetalRough || pbrSpecGloss)

            } // geometry.normals

            //--------------------------------------------------------------------------------
            // GEOMETRY INPUTS
            //--------------------------------------------------------------------------------

            add(&quot;varying vec3 vViewPosition;&quot;);

            if (geometry.colors) {
                add(&quot;varying vec4 vColor;&quot;);
            }

            if (geometry.uv &amp;&amp; ((geometry.normals &amp;&amp; material.normalMap)
                || material.ambientMap
                || material.baseColorMap
                || material.diffuseMap
                || material.emissiveMap
                || material.metallicMap
                || material.roughnessMap
                || material.metallicRoughnessMap
                || material.specularMap
                || material.glossinessMap
                || material.specularGlossinessMap
                || material.occlusionMap
                || material.alphaMap)) {
                add(&quot;varying vec2 vUV;&quot;);
            }

            if (geometry.normals) {
                if (states.lights.lightMap) {
                    add(&quot;varying vec3 vWorldNormal;&quot;);
                }
                add(&quot;varying vec3 vViewNormal;&quot;);
            }

            //--------------------------------------------------------------------------------
            // MATERIAL CHANNEL INPUTS
            //--------------------------------------------------------------------------------

            if (material.ambient) {
                add(&quot;uniform vec3 materialAmbient;&quot;);
            }

            if (material.baseColor) {
                add(&quot;uniform vec3 materialBaseColor;&quot;);
            }

            if (material.alpha !== undefined &amp;&amp; material.alpha !== null) {
                add(&quot;uniform vec4 materialAlphaModeCutoff;&quot;); // [alpha, alphaMode, alphaCutoff]
            }

            if (material.emissive) {
                add(&quot;uniform vec3 materialEmissive;&quot;);
            }

            if (material.diffuse) {
                add(&quot;uniform vec3 materialDiffuse;&quot;);
            }

            if (material.glossiness !== undefined &amp;&amp; material.glossiness !== null) {
                add(&quot;uniform float materialGlossiness;&quot;);
            }

            if (material.shininess !== undefined &amp;&amp; material.shininess !== null) {
                add(&quot;uniform float materialShininess;&quot;);  // Phong channel
            }

            if (material.specular) {
                add(&quot;uniform vec3 materialSpecular;&quot;);
            }

            if (material.metallic !== undefined &amp;&amp; material.metallic !== null) {
                add(&quot;uniform float materialMetallic;&quot;);
            }

            if (material.roughness !== undefined &amp;&amp; material.roughness !== null) {
                add(&quot;uniform float materialRoughness;&quot;);
            }

            if (material.specularF0 !== undefined &amp;&amp; material.specularF0 !== null) {
                add(&quot;uniform float materialSpecularF0;&quot;);
            }

            //--------------------------------------------------------------------------------
            // MATERIAL TEXTURE INPUTS
            //--------------------------------------------------------------------------------

            if (geometry.uv &amp;&amp; material.ambientMap) {
                add(&quot;uniform sampler2D ambientMap;&quot;);
                if (material.ambientMap.matrix) {
                    add(&quot;uniform mat4 ambientMapMatrix;&quot;);
                }
            }

            if (geometry.uv &amp;&amp; material.baseColorMap) {
                add(&quot;uniform sampler2D baseColorMap;&quot;);
                if (material.baseColorMap.matrix) {
                    add(&quot;uniform mat4 baseColorMapMatrix;&quot;);
                }
            }

            if (geometry.uv &amp;&amp; material.diffuseMap) {
                add(&quot;uniform sampler2D diffuseMap;&quot;);
                if (material.diffuseMap.matrix) {
                    add(&quot;uniform mat4 diffuseMapMatrix;&quot;);
                }
            }

            if (geometry.uv &amp;&amp; material.emissiveMap) {
                add(&quot;uniform sampler2D emissiveMap;&quot;);
                if (material.emissiveMap.matrix) {
                    add(&quot;uniform mat4 emissiveMapMatrix;&quot;);
                }
            }

            if (geometry.normals &amp;&amp; geometry.uv &amp;&amp; material.metallicMap) {
                add(&quot;uniform sampler2D metallicMap;&quot;);
                if (material.metallicMap.matrix) {
                    add(&quot;uniform mat4 metallicMapMatrix;&quot;);
                }
            }

            if (geometry.normals &amp;&amp; geometry.uv &amp;&amp; material.roughnessMap) {
                add(&quot;uniform sampler2D roughnessMap;&quot;);
                if (material.roughnessMap.matrix) {
                    add(&quot;uniform mat4 roughnessMapMatrix;&quot;);
                }
            }

            if (geometry.normals &amp;&amp; geometry.uv &amp;&amp; material.metallicRoughnessMap) {
                add(&quot;uniform sampler2D metallicRoughnessMap;&quot;);
                if (material.metallicRoughnessMap.matrix) {
                    add(&quot;uniform mat4 metallicRoughnessMapMatrix;&quot;);
                }
            }

            if (geometry.normals &amp;&amp; material.normalMap) {
                add(&quot;varying mat3 vTBN;&quot;);
                add(&quot;uniform sampler2D normalMap;&quot;);
                if (material.normalMap.matrix) {
                    add(&quot;uniform mat4 normalMapMatrix;&quot;);
                }
            }

            if (geometry.uv &amp;&amp; material.occlusionMap) {
                add(&quot;uniform sampler2D occlusionMap;&quot;);
                if (material.occlusionMap.matrix) {
                    add(&quot;uniform mat4 occlusionMapMatrix;&quot;);
                }
            }

            if (geometry.uv &amp;&amp; material.alphaMap) {
                add(&quot;uniform sampler2D alphaMap;&quot;);
                if (material.alphaMap.matrix) {
                    add(&quot;uniform mat4 alphaMapMatrix;&quot;);
                }
            }

            if (geometry.normals &amp;&amp; geometry.uv &amp;&amp; material.specularMap) {
                add(&quot;uniform sampler2D specularMap;&quot;);
                if (material.specularMap.matrix) {
                    add(&quot;uniform mat4 specularMapMatrix;&quot;);
                }
            }

            if (geometry.normals &amp;&amp; geometry.uv &amp;&amp; material.glossinessMap) {
                add(&quot;uniform sampler2D glossinessMap;&quot;);
                if (material.glossinessMap.matrix) {
                    add(&quot;uniform mat4 glossinessMapMatrix;&quot;);
                }
            }

            if (geometry.normals &amp;&amp; geometry.uv &amp;&amp; material.specularGlossinessMap) {
                add(&quot;uniform sampler2D materialSpecularGlossinessMap;&quot;);
                if (material.specularGlossinessMap.matrix) {
                    add(&quot;uniform mat4 materialSpecularGlossinessMapMatrix;&quot;);
                }
            }

            //--------------------------------------------------------------------------------
            // MATERIAL FRESNEL INPUTS
            //--------------------------------------------------------------------------------

            if (geometry.normals &amp;&amp; (material.diffuseFresnel ||
                material.specularFresnel ||
                material.alphaFresnel ||
                material.emissiveFresnel ||
                material.reflectivityFresnel)) {

                add(&quot;float fresnel(vec3 eyeDir, vec3 normal, float edgeBias, float centerBias, float power) {&quot;);
                add(&quot;    float fr = abs(dot(eyeDir, normal));&quot;);
                add(&quot;    float finalFr = clamp((fr - edgeBias) / (centerBias - edgeBias), 0.0, 1.0);&quot;);
                add(&quot;    return pow(finalFr, power);&quot;);
                add(&quot;}&quot;);

                if (material.diffuseFresnel) {
                    add(&quot;uniform float  diffuseFresnelCenterBias;&quot;);
                    add(&quot;uniform float  diffuseFresnelEdgeBias;&quot;);
                    add(&quot;uniform float  diffuseFresnelPower;&quot;);
                    add(&quot;uniform vec3   diffuseFresnelCenterColor;&quot;);
                    add(&quot;uniform vec3   diffuseFresnelEdgeColor;&quot;);
                }

                if (material.specularFresnel) {
                    add(&quot;uniform float  specularFresnelCenterBias;&quot;);
                    add(&quot;uniform float  specularFresnelEdgeBias;&quot;);
                    add(&quot;uniform float  specularFresnelPower;&quot;);
                    add(&quot;uniform vec3   specularFresnelCenterColor;&quot;);
                    add(&quot;uniform vec3   specularFresnelEdgeColor;&quot;);
                }

                if (material.alphaFresnel) {
                    add(&quot;uniform float  alphaFresnelCenterBias;&quot;);
                    add(&quot;uniform float  alphaFresnelEdgeBias;&quot;);
                    add(&quot;uniform float  alphaFresnelPower;&quot;);
                    add(&quot;uniform vec3   alphaFresnelCenterColor;&quot;);
                    add(&quot;uniform vec3   alphaFresnelEdgeColor;&quot;);
                }

                if (material.reflectivityFresnel) {
                    add(&quot;uniform float  materialSpecularF0FresnelCenterBias;&quot;);
                    add(&quot;uniform float  materialSpecularF0FresnelEdgeBias;&quot;);
                    add(&quot;uniform float  materialSpecularF0FresnelPower;&quot;);
                    add(&quot;uniform vec3   materialSpecularF0FresnelCenterColor;&quot;);
                    add(&quot;uniform vec3   materialSpecularF0FresnelEdgeColor;&quot;);
                }

                if (material.emissiveFresnel) {
                    add(&quot;uniform float  emissiveFresnelCenterBias;&quot;);
                    add(&quot;uniform float  emissiveFresnelEdgeBias;&quot;);
                    add(&quot;uniform float  emissiveFresnelPower;&quot;);
                    add(&quot;uniform vec3   emissiveFresnelCenterColor;&quot;);
                    add(&quot;uniform vec3   emissiveFresnelEdgeColor;&quot;);
                }
            }

            //--------------------------------------------------------------------------------
            // LIGHT SOURCES
            //--------------------------------------------------------------------------------

            add(&quot;uniform vec3   lightAmbient;&quot;);
            add(&quot;uniform float  lightAmbientIntensity;&quot;);

            if (geometry.normals) {

                for (i = 0, len = lights.length; i &lt; len; i++) { // Light sources

                    light = lights[i];

                    if (light.type === &quot;ambient&quot;) {
                        continue;
                    }

                    add(&quot;uniform vec3 lightColor&quot; + i + &quot;;&quot;);
                    add(&quot;uniform float lightIntensity&quot; + i + &quot;;&quot;);

                    if (light.type === &quot;point&quot;) {
                        add(&quot;uniform vec3 lightAttenuation&quot; + i + &quot;;&quot;);
                    }
                    if (light.type === &quot;dir&quot; &amp;&amp; light.space === &quot;view&quot;) {
                        add(&quot;uniform vec3 lightDir&quot; + i + &quot;;&quot;);
                    }
                    if (light.type === &quot;point&quot; &amp;&amp; light.space === &quot;view&quot;) {
                        add(&quot;uniform vec3 lightPos&quot; + i + &quot;;&quot;);
                    } else {
                        add(&quot;varying vec4 vViewLightReverseDirAndDist&quot; + i + &quot;;&quot;);
                    }
                }
            }

            //--------------------------------------------------------------------------------
            // SHADOWS
            //--------------------------------------------------------------------------------

            if (receiveShadow) {
                for (i = 0, len = lights.length; i &lt; len; i++) { // Light sources
                    if (lights[i].shadow) {
                        add(&quot;varying vec4 vShadowPosFromLight&quot; + i + &quot;;&quot;);
                        add(&quot;uniform sampler2D shadowMap&quot; + i + &quot;;&quot;);
                    }
                }
            }

            //================================================================================
            // MAIN
            //================================================================================

            add(&quot;void main(void) {&quot;);

            if (clipping) {
                add(&quot;if (clippable) {&quot;);
                add(&quot;  float dist = 0.0;&quot;);
                for (var i = 0; i &lt; states.clips.clips.length; i++) {
                    add(&quot;if (clipActive&quot; + i + &quot;) {&quot;);
                    add(&quot;   dist += clamp(dot(-clipDir&quot; + i + &quot;.xyz, vWorldPosition.xyz - clipPos&quot; + i + &quot;.xyz), 0.0, 1000.0);&quot;);
                    add(&quot;}&quot;);
                }
                add(&quot;  if (dist &gt; 0.0) { discard; }&quot;);
                add(&quot;}&quot;);
            }

            if (geometry.primitiveName === &quot;points&quot;) {
                add(&quot;vec2 cxy = 2.0 * gl_PointCoord - 1.0;&quot;);
                add(&quot;float r = dot(cxy, cxy);&quot;);
                add(&quot;if (r &gt; 1.0) {&quot;);
                add(&quot;   discard;&quot;);
                add(&quot;}&quot;);
            }

            add(&quot;float occlusion = 1.0;&quot;);

            if (material.ambient) {
                add(&quot;vec3 ambientColor = materialAmbient;&quot;);
            } else {
                add(&quot;vec3 ambientColor = vec3(1.0, 1.0, 1.0);&quot;);
            }

            if (material.diffuse) {
                add(&quot;vec3 diffuseColor = materialDiffuse;&quot;);
            } else if (material.baseColor) {
                add(&quot;vec3 diffuseColor = materialBaseColor;&quot;);
            } else {
                add(&quot;vec3 diffuseColor = vec3(1.0, 1.0, 1.0);&quot;);
            }

            if (geometry.colors) {
                add(&quot;diffuseColor *= vColor.rgb;&quot;);
            }

            if (material.emissive) {
                add(&quot;vec3 emissiveColor = materialEmissive;&quot;); // Emissive default is (0,0,0), so initializing here
            } else {
                add(&quot;vec3  emissiveColor = vec3(0.0, 0.0, 0.0);&quot;);
            }

            if (material.specular) {
                add(&quot;vec3 specular = materialSpecular;&quot;);
            } else {
                add(&quot;vec3 specular = vec3(1.0, 1.0, 1.0);&quot;);
            }

            if (material.alpha !== undefined) {
                add(&quot;float alpha = materialAlphaModeCutoff[0];&quot;);
            } else {
                add(&quot;float alpha = 1.0;&quot;);
            }

            if (geometry.colors) {
                add(&quot;alpha *= vColor.a;&quot;);
            }

            if (material.glossiness !== undefined) {
                add(&quot;float glossiness = materialGlossiness;&quot;);
            } else {
                add(&quot;float glossiness = 1.0;&quot;);
            }

            if (material.metallic !== undefined) {
                add(&quot;float metallic = materialMetallic;&quot;);
            } else {
                add(&quot;float metallic = 1.0;&quot;);
            }

            if (material.roughness !== undefined) {
                add(&quot;float roughness = materialRoughness;&quot;);
            } else {
                add(&quot;float roughness = 1.0;&quot;);
            }

            if (material.specularF0 !== undefined) {
                add(&quot;float specularF0 = materialSpecularF0;&quot;);
            } else {
                add(&quot;float specularF0 = 1.0;&quot;);
            }

            //--------------------------------------------------------------------------------
            // TEXTURING
            //--------------------------------------------------------------------------------

            if (geometry.uv
                &amp;&amp; ((geometry.normals &amp;&amp; material.normalMap)
                || material.ambientMap
                || material.baseColorMap
                || material.diffuseMap
                || material.occlusionMap
                || material.emissiveMap
                || material.metallicMap
                || material.roughnessMap
                || material.metallicRoughnessMap
                || material.specularMap
                || material.glossinessMap
                || material.specularGlossinessMap
                || material.alphaMap)) {
                add(&quot;vec4 texturePos = vec4(vUV.s, vUV.t, 1.0, 1.0);&quot;);
                add(&quot;vec2 textureCoord;&quot;);
            }

            if (geometry.uv &amp;&amp; material.ambientMap) {
                if (material.ambientMap.matrix) {
                    add(&quot;textureCoord = (ambientMapMatrix * texturePos).xy;&quot;);
                } else {
                    add(&quot;textureCoord = texturePos.xy;&quot;);
                }
                add(&quot;ambientColor *= texture2D(ambientMap, textureCoord).rgb;&quot;);
            }

            if (geometry.uv &amp;&amp; material.diffuseMap) {
                if (material.diffuseMap.matrix) {
                    add(&quot;textureCoord = (diffuseMapMatrix * texturePos).xy;&quot;);
                } else {
                    add(&quot;textureCoord = texturePos.xy;&quot;);
                }
                add(&quot;vec4 diffuseTexel = texture2D(diffuseMap, textureCoord);&quot;);
                add(&quot;diffuseColor *= diffuseTexel.rgb;&quot;);
                add(&quot;alpha *= diffuseTexel.a;&quot;);
            }

            if (geometry.uv &amp;&amp; material.baseColorMap) {
                if (material.baseColorMap.matrix) {
                    add(&quot;textureCoord = (baseColorMapMatrix * texturePos).xy;&quot;);
                } else {
                    add(&quot;textureCoord = texturePos.xy;&quot;);
                }
                add(&quot;vec4 baseColorTexel = texture2D(baseColorMap, textureCoord);&quot;);
                add(&quot;diffuseColor *= baseColorTexel.rgb;&quot;);
                add(&quot;alpha *= baseColorTexel.a;&quot;);
            }

            if (geometry.uv &amp;&amp; material.emissiveMap) {
                if (material.emissiveMap.matrix) {
                    add(&quot;textureCoord = (emissiveMapMatrix * texturePos).xy;&quot;);
                } else {
                    add(&quot;textureCoord = texturePos.xy;&quot;);
                }
                add(&quot;emissiveColor *= texture2D(emissiveMap, textureCoord).rgb;&quot;);
            }

            if (geometry.uv &amp;&amp; material.alphaMap) {
                if (material.alphaMap.matrix) {
                    add(&quot;textureCoord = (alphaMapMatrix * texturePos).xy;&quot;);
                } else {
                    add(&quot;textureCoord = texturePos.xy;&quot;);
                }
                add(&quot;alpha *= texture2D(alphaMap, textureCoord).r;&quot;);
            }

            if (geometry.uv &amp;&amp; material.occlusionMap) {
                if (material.occlusionMap.matrix) {
                    add(&quot;textureCoord = (occlusionMapMatrix * texturePos).xy;&quot;);
                } else {
                    add(&quot;textureCoord = texturePos.xy;&quot;);
                }
                add(&quot;occlusion *= texture2D(occlusionMap, textureCoord).r;&quot;);
            }

            if (geometry.normals &amp;&amp; ((lights.length &gt; 0) || states.lights.lightMap || states.lights.reflectionMap)) {

                //--------------------------------------------------------------------------------
                // SHADING
                //--------------------------------------------------------------------------------

                if (geometry.uv &amp;&amp; material.normalMap) {
                    if (material.normalMap.matrix) {
                        add(&quot;textureCoord = (normalMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;vec3 viewNormal = vTBN * normalize( texture2D(normalMap, vec2(textureCoord.x, textureCoord.y) ).rgb * 2.0 - 1.0);&quot;);
                } else {
                    add(&quot;vec3 viewNormal = normalize(vViewNormal);&quot;);
                }

                if (geometry.uv &amp;&amp; material.specularMap) {
                    if (material.specularMap.matrix) {
                        add(&quot;textureCoord = (specularMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;specular *= texture2D(specularMap, textureCoord).rgb;&quot;);
                }

                if (geometry.uv &amp;&amp; material.glossinessMap) {
                    if (material.glossinessMap.matrix) {
                        add(&quot;textureCoord = (glossinessMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;glossiness *= texture2D(glossinessMap, textureCoord).r;&quot;);
                }

                if (geometry.uv &amp;&amp; material.specularGlossinessMap) {
                    if (material.specularGlossinessMap.matrix) {
                        add(&quot;textureCoord = (materialSpecularGlossinessMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;vec4 specGlossRGB = texture2D(materialSpecularGlossinessMap, textureCoord).rgba;&quot;); // TODO: what if only RGB texture?
                    add(&quot;specular *= specGlossRGB.rgb;&quot;);
                    add(&quot;glossiness *= specGlossRGB.a;&quot;);
                }

                if (geometry.uv &amp;&amp; material.metallicMap) {
                    if (material.metallicMap.matrix) {
                        add(&quot;textureCoord = (metallicMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;metallic *= texture2D(metallicMap, textureCoord).r;&quot;);
                }

                if (geometry.uv &amp;&amp; material.roughnessMap) {
                    if (material.roughnessMap.matrix) {
                        add(&quot;textureCoord = (roughnessMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;roughness *= texture2D(roughnessMap, textureCoord).r;&quot;);
                }

                if (geometry.uv &amp;&amp; material.metallicRoughnessMap) {
                    if (material.metallicRoughnessMap.matrix) {
                        add(&quot;textureCoord = (metallicRoughnessMapMatrix * texturePos).xy;&quot;);
                    } else {
                        add(&quot;textureCoord = texturePos.xy;&quot;);
                    }
                    add(&quot;vec3 metalRoughRGB = texture2D(metallicRoughnessMap, textureCoord).rgb;&quot;);
                    add(&quot;metallic *= metalRoughRGB.b;&quot;);
                    add(&quot;roughness *= metalRoughRGB.g;&quot;);
                }

                add(&quot;vec3 viewEyeDir = normalize(-vViewPosition);&quot;);

                if (material.diffuseFresnel || material.specularFresnel || material.alphaFresnel || material.emissiveFresnel || material.reflectivityFresnel) {
                    if (material.diffuseFresnel) {
                        add(&quot;float diffuseFresnel = fresnel(viewEyeDir, viewNormal, diffuseFresnelEdgeBias, diffuseFresnelCenterBias, diffuseFresnelPower);&quot;);
                        add(&quot;diffuseColor *= mix(diffuseFresnelEdgeColor, diffuseFresnelCenterColor, diffuseFresnel);&quot;);
                    }
                    if (material.specularFresnel) {
                        add(&quot;float specularFresnel = fresnel(viewEyeDir, viewNormal, specularFresnelEdgeBias, specularFresnelCenterBias, specularFresnelPower);&quot;);
                        add(&quot;specular *= mix(specularFresnelEdgeColor, specularFresnelCenterColor, specularFresnel);&quot;);
                    }
                    if (material.alphaFresnel) {
                        add(&quot;float alphaFresnel = fresnel(viewEyeDir, viewNormal, alphaFresnelEdgeBias, alphaFresnelCenterBias, alphaFresnelPower);&quot;);
                        add(&quot;alpha *= mix(alphaFresnelEdgeColor.r, alphaFresnelCenterColor.r, alphaFresnel);&quot;);
                    }
                    if (material.emissiveFresnel) {
                        add(&quot;float emissiveFresnel = fresnel(viewEyeDir, viewNormal, emissiveFresnelEdgeBias, emissiveFresnelCenterBias, emissiveFresnelPower);&quot;);
                        add(&quot;emissiveColor *= mix(emissiveFresnelEdgeColor, emissiveFresnelCenterColor, emissiveFresnel);&quot;);
                    }
                }

                add(&quot;if (materialAlphaModeCutoff[1] == 1.0 &amp;&amp; alpha &lt; materialAlphaModeCutoff[2]) {&quot;); // ie. (alphaMode == &quot;mask&quot; &amp;&amp; alpha &lt; alphaCutoff)
                add(&quot;   discard;&quot;); // TODO: Discard earlier within this shader?
                add(&quot;}&quot;);

                // PREPARE INPUTS FOR SHADER FUNCTIONS

                add(&quot;IncidentLight  light;&quot;);
                add(&quot;Material       material;&quot;);
                add(&quot;Geometry       geometry;&quot;);
                add(&quot;ReflectedLight reflectedLight = ReflectedLight(vec3(0.0,0.0,0.0), vec3(0.0,0.0,0.0));&quot;);
                add(&quot;vec3           viewLightDir;&quot;);

                if (phongMaterial) {
                    add(&quot;material.diffuseColor      = diffuseColor;&quot;);
                    add(&quot;material.specularColor     = specular;&quot;);
                    add(&quot;material.shine             = materialShininess;&quot;);
                }

                if (pbrSpecGloss) {
                    add(&quot;float oneMinusSpecularStrength = 1.0 - max(max(specular.r, specular.g ),specular.b);&quot;); // Energy conservation
                    add(&quot;material.diffuseColor      = diffuseColor * oneMinusSpecularStrength;&quot;);
                    add(&quot;material.specularRoughness = clamp( 1.0 - glossiness, 0.04, 1.0 );&quot;);
                    add(&quot;material.specularColor     = specular;&quot;);
                }

                if (pbrMetalRough) {
                    add(&quot;float dielectricSpecular = 0.16 * specularF0 * specularF0;&quot;);
                    add(&quot;material.diffuseColor      = diffuseColor * (1.0 - dielectricSpecular) * (1.0 - metallic);&quot;);
                    add(&quot;material.specularRoughness = clamp(roughness, 0.04, 1.0);&quot;);
                    add(&quot;material.specularColor     = mix(vec3(dielectricSpecular), diffuseColor, metallic);&quot;);
                }

                add(&quot;geometry.position      = vViewPosition;&quot;);
                if (states.lights.lightMap) {
                    add(&quot;geometry.worldNormal   = normalize(vWorldNormal);&quot;);
                }
                add(&quot;geometry.viewNormal    = viewNormal;&quot;);
                add(&quot;geometry.viewEyeDir    = viewEyeDir;&quot;);

                // ENVIRONMENT AND REFLECTION MAP SHADING

                if ((phongMaterial) &amp;&amp; (states.lights.lightMap || states.lights.reflectionMap)) {
                    add(&quot;computePhongLightMapping(geometry, material, reflectedLight);&quot;);
                }

                if ((pbrSpecGloss || pbrMetalRough) &amp;&amp; (states.lights.lightMap || states.lights.reflectionMap)) {
                    add(&quot;computePBRLightMapping(geometry, material, reflectedLight);&quot;);
                }

                // LIGHT SOURCE SHADING

                var light;

                for (i = 0, len = lights.length; i &lt; len; i++) {

                    light = lights[i];

                    if (light.type === &quot;ambient&quot;) {
                        continue;
                    }
                    if (light.type === &quot;dir&quot; &amp;&amp; light.space === &quot;view&quot;) {
                        add(&quot;viewLightDir = -normalize(lightDir&quot; + i + &quot;);&quot;);
                    } else if (light.type === &quot;point&quot; &amp;&amp; light.space === &quot;view&quot;) {
                        add(&quot;viewLightDir = normalize(lightPos&quot; + i + &quot; - vViewPosition);&quot;);
                        //add(&quot;tmpVec3 = lightPos&quot; + i + &quot;.xyz - viewPosition.xyz;&quot;);
                        //add(&quot;lightDist = abs(length(tmpVec3));&quot;);
                    } else {
                        add(&quot;viewLightDir = normalize(vViewLightReverseDirAndDist&quot; + i + &quot;.xyz);&quot;); // If normal mapping, the fragment-&gt;light vector will be in tangent space
                    }

                    add(&quot;light.direction = viewLightDir;&quot;);
                    add(&quot;light.color = lightIntensity&quot; + i + &quot; * lightColor&quot; + i + &quot;;&quot;);

                    if (phongMaterial) {
                        add(&quot;computePhongLighting(light, geometry, material, reflectedLight);&quot;);
                    }

                    if (pbrSpecGloss || pbrMetalRough) {
                        add(&quot;computePBRLighting(light, geometry, material, reflectedLight);&quot;);
                    }
                }

                //--------------------------------------------------------------------------------
                // Shadow mapping
                //--------------------------------------------------------------------------------

                add(&quot;float shadow = 1.0;&quot;);

                if (receiveShadow) {

                    add(&quot;vec3 shadowCoord;&quot;);
                    add(&quot;float depth;&quot;);
                    add(&quot;vec4 rgbaDepth;&quot;);

                    for (i = 0, len = lights.length; i &lt; len; i++) { // Light sources

                        light = lights[i];

                        if (light.shadow) {
                            add(&quot;shadowCoord = (vShadowPosFromLight&quot; + i + &quot;.xyz / vShadowPosFromLight&quot; + i + &quot;.w) / 2.0 - 1.0;&quot;);
                            add(&quot;rgbaDepth = texture2D(shadowMap&quot; + i + &quot;, shadowCoord.xy);&quot;);
                            add(&quot;depth = rgbaDepth.r;&quot;);
                            add(&quot;shadow *= (shadowCoord.z &gt; depth + 0.005) ? 0.7 : 1.0;&quot;);
                            //add(&quot;shadow *= (shadowCoord.z == 0.0) ? 0.2 : 1.0;&quot;);
                        }
                    }
                }

                // COMBINE TERMS

                if (phongMaterial) {

                    add(&quot;ambientColor *= (lightAmbient * lightAmbientIntensity);&quot;);

                    add(&quot;vec3 outgoingLight =  (shadow * occlusion * (ambientColor + reflectedLight.diffuse + reflectedLight.specular)) + emissiveColor;&quot;);

                } else {
                    add(&quot;vec3 outgoingLight = (shadow * occlusion * reflectedLight.diffuse) + (shadow * occlusion * reflectedLight.specular) + emissiveColor;&quot;);
                }

            } else {

                //--------------------------------------------------------------------------------
                // NO SHADING - EMISSIVE and AMBIENT ONLY
                //--------------------------------------------------------------------------------

                add(&quot;ambientColor *= (lightAmbient * lightAmbientIntensity);&quot;);

                add(&quot;vec3 outgoingLight = emissiveColor + ambientColor;&quot;);
            }

            add(&quot;gl_FragColor = vec4(outgoingLight, alpha);&quot;);
            //    add(&quot;gl_FragColor = LinearTosRGB(gl_FragColor);&quot;);  // Gamma correction

            add(&quot;}&quot;);

            return end();
        }

        // Start fresh program source
        function begin() {
            src = [];
        }

        // Append to program source
        function add(txt) {
            src.push(txt || &quot;&quot;);
        }

        // Finish building program source
        function end() {
            return src;
        }

        function getFSFloatPrecision(gl) {

            if (!gl.getShaderPrecisionFormat) {
                return &quot;mediump&quot;;
            }

            if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision &gt; 0) {
                return &quot;highp&quot;;
            }

            if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision &gt; 0) {
                return &quot;mediump&quot;;
            }

            return &quot;lowp&quot;;
        }

    })
    ();

})
();
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
