<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/_renderer/renderer.js - xeogl</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link href='https://fonts.googleapis.com/css?family=Exo+2:400,800,900,700,600,500|Roboto:100,300,400,500,700,900'  rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">

                <h1 class="projectTitle"><a href="../../">xeogl</a> / <a href="../../docs">API Docs</a></h1>

        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AABBGeometry.html">AABBGeometry</a></li>
                                <li><a href="../classes/AABBHelper.html">AABBHelper</a></li>
                                <li><a href="../classes/AmbientLight.html">AmbientLight</a></li>
                                <li><a href="../classes/Annotation.html">Annotation</a></li>
                                <li><a href="../classes/AnnotationStory.html">AnnotationStory</a></li>
                                <li><a href="../classes/AxisHelper.html">AxisHelper</a></li>
                                <li><a href="../classes/Boundary2D.html">Boundary2D</a></li>
                                <li><a href="../classes/Boundary3D.html">Boundary3D</a></li>
                                <li><a href="../classes/BoxGeometry.html">BoxGeometry</a></li>
                                <li><a href="../classes/BuildableModel.html">BuildableModel</a></li>
                                <li><a href="../classes/Camera.html">Camera</a></li>
                                <li><a href="../classes/CameraControl.html">CameraControl</a></li>
                                <li><a href="../classes/CameraController.html">CameraController</a></li>
                                <li><a href="../classes/CameraFlightAnimation.html">CameraFlightAnimation</a></li>
                                <li><a href="../classes/CameraFollowAnimation.html">CameraFollowAnimation</a></li>
                                <li><a href="../classes/CameraPath.html">CameraPath</a></li>
                                <li><a href="../classes/CameraPathAnimation.html">CameraPathAnimation</a></li>
                                <li><a href="../classes/Canvas.html">Canvas</a></li>
                                <li><a href="../classes/CardboardEffect.html">CardboardEffect</a></li>
                                <li><a href="../classes/Clip.html">Clip</a></li>
                                <li><a href="../classes/ClipHelper.html">ClipHelper</a></li>
                                <li><a href="../classes/Clips.html">Clips</a></li>
                                <li><a href="../classes/Component.html">Component</a></li>
                                <li><a href="../classes/Configs.html">Configs</a></li>
                                <li><a href="../classes/CubeTexture.html">CubeTexture</a></li>
                                <li><a href="../classes/CubicBezierCurve.html">CubicBezierCurve</a></li>
                                <li><a href="../classes/Curve.html">Curve</a></li>
                                <li><a href="../classes/CylinderGeometry.html">CylinderGeometry</a></li>
                                <li><a href="../classes/DirLight.html">DirLight</a></li>
                                <li><a href="../classes/Entity.html">Entity</a></li>
                                <li><a href="../classes/Fog.html">Fog</a></li>
                                <li><a href="../classes/Fresnel.html">Fresnel</a></li>
                                <li><a href="../classes/Frustum.html">Frustum</a></li>
                                <li><a href="../classes/Geometry.html">Geometry</a></li>
                                <li><a href="../classes/GeometryBuilder.html">GeometryBuilder</a></li>
                                <li><a href="../classes/GLTFModel.html">GLTFModel</a></li>
                                <li><a href="../classes/HeightmapGeometry.html">HeightmapGeometry</a></li>
                                <li><a href="../classes/Input.html">Input</a></li>
                                <li><a href="../classes/InputControl.html">InputControl</a></li>
                                <li><a href="../classes/LabelHelper.html">LabelHelper</a></li>
                                <li><a href="../classes/Lights.html">Lights</a></li>
                                <li><a href="../classes/Lookat.html">Lookat</a></li>
                                <li><a href="../classes/Material.html">Material</a></li>
                                <li><a href="../classes/MetallicMaterial.html">MetallicMaterial</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/MousePickControl.html">MousePickControl</a></li>
                                <li><a href="../classes/Nintendo3DSGeometry.html">Nintendo3DSGeometry</a></li>
                                <li><a href="../classes/OBBGeometry.html">OBBGeometry</a></li>
                                <li><a href="../classes/OBBHelper.html">OBBHelper</a></li>
                                <li><a href="../classes/OBJGeometry.html">OBJGeometry</a></li>
                                <li><a href="../classes/OBJModel.html">OBJModel</a></li>
                                <li><a href="../classes/Ortho.html">Ortho</a></li>
                                <li><a href="../classes/Outline.html">Outline</a></li>
                                <li><a href="../classes/Path.html">Path</a></li>
                                <li><a href="../classes/PathGeometry.html">PathGeometry</a></li>
                                <li><a href="../classes/Perspective.html">Perspective</a></li>
                                <li><a href="../classes/PhongMaterial.html">PhongMaterial</a></li>
                                <li><a href="../classes/Pin.html">Pin</a></li>
                                <li><a href="../classes/PlaneGeometry.html">PlaneGeometry</a></li>
                                <li><a href="../classes/PlaneHelper.html">PlaneHelper</a></li>
                                <li><a href="../classes/PointLight.html">PointLight</a></li>
                                <li><a href="../classes/PointLightHelper.html">PointLightHelper</a></li>
                                <li><a href="../classes/PointMarkings.html">PointMarkings</a></li>
                                <li><a href="../classes/QuadraticBezierCurve.html">QuadraticBezierCurve</a></li>
                                <li><a href="../classes/Quaternion.html">Quaternion</a></li>
                                <li><a href="../classes/Region.html">Region</a></li>
                                <li><a href="../classes/Rotate.html">Rotate</a></li>
                                <li><a href="../classes/Ruler.html">Ruler</a></li>
                                <li><a href="../classes/Scale.html">Scale</a></li>
                                <li><a href="../classes/Scene.html">Scene</a></li>
                                <li><a href="../classes/SceneJSModel.html">SceneJSModel</a></li>
                                <li><a href="../classes/Shadow.html">Shadow</a></li>
                                <li><a href="../classes/Skybox.html">Skybox</a></li>
                                <li><a href="../classes/SpecularMaterial.html">SpecularMaterial</a></li>
                                <li><a href="../classes/SphereGeometry.html">SphereGeometry</a></li>
                                <li><a href="../classes/Spinner.html">Spinner</a></li>
                                <li><a href="../classes/SplineCurve.html">SplineCurve</a></li>
                                <li><a href="../classes/SplineCurveHelper.html">SplineCurveHelper</a></li>
                                <li><a href="../classes/SpotLight.html">SpotLight</a></li>
                                <li><a href="../classes/StereoEffect.html">StereoEffect</a></li>
                                <li><a href="../classes/Story.html">Story</a></li>
                                <li><a href="../classes/TeapotGeometry.html">TeapotGeometry</a></li>
                                <li><a href="../classes/Texture.html">Texture</a></li>
                                <li><a href="../classes/TorusGeometry.html">TorusGeometry</a></li>
                                <li><a href="../classes/Transform.html">Transform</a></li>
                                <li><a href="../classes/Translate.html">Translate</a></li>
                                <li><a href="../classes/VectorTextGeometry.html">VectorTextGeometry</a></li>
                                <li><a href="../classes/ViewCube.html">ViewCube</a></li>
                                <li><a href="../classes/Viewport.html">Viewport</a></li>
                                <li><a href="../classes/xeogl.html">xeogl</a></li>
                                <li><a href="../classes/xeogl.math.math.html">xeogl.math.math</a></li>
                                <li><a href="../classes/XRay.html">XRay</a></li>
                                <li><a href="../classes/ZSpaceEffect.html">ZSpaceEffect</a></li>
                                <li><a href="../classes/ZSpaceStylusControl.html">ZSpaceStylusControl</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="..//modules/animation.html">animation</a></li>
                                <li><a href="..//modules/annotations.html">annotations</a></li>
                                <li><a href="..//modules/boundaries.html">boundaries</a></li>
                                <li><a href="..//modules/camera.html">camera</a></li>
                                <li><a href="..//modules/canvas.html">canvas</a></li>
                                <li><a href="..//modules/clipping.html">clipping</a></li>
                                <li><a href="..//modules/configs.html">configs</a></li>
                                <li><a href="..//modules/controls.html">controls</a></li>
                                <li><a href="..//modules/curves.html">curves</a></li>
                                <li><a href="..//modules/effects.html">effects</a></li>
                                <li><a href="..//modules/emphasis.html">emphasis</a></li>
                                <li><a href="..//modules/entities.html">entities</a></li>
                                <li><a href="..//modules/generation.html">generation</a></li>
                                <li><a href="..//modules/geometry.html">geometry</a></li>
                                <li><a href="..//modules/helpers.html">helpers</a></li>
                                <li><a href="..//modules/input.html">input</a></li>
                                <li><a href="..//modules/interaction.html">interaction</a></li>
                                <li><a href="..//modules/lighting.html">lighting</a></li>
                                <li><a href="..//modules/marking.html">marking</a></li>
                                <li><a href="..//modules/materials.html">materials</a></li>
                                <li><a href="..//modules/math.html">math</a></li>
                                <li><a href="..//modules/models.html">models</a></li>
                                <li><a href="..//modules/outline.html">outline</a></li>
                                <li><a href="..//modules/rendering.html">rendering</a></li>
                                <li><a href="..//modules/skyboxes.html">skyboxes</a></li>
                                <li><a href="..//modules/stories.html">stories</a></li>
                                <li><a href="..//modules/transforms.html">transforms</a></li>
                                <li><a href="..//modules/xeogl.html">xeogl</a></li>
                                <li><a href="..//modules/zspace.html">zspace</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <!--<div id="api-options">-->
                    <!--Show:-->
                    <!--<label for="api-show-inherited">-->
                        <!--<input type="checkbox" id="api-show-inherited" checked>-->
                        <!--Inherited-->
                    <!--</label>-->
            
                    <!--<label for="api-show-protected">-->
                        <!--<input type="checkbox" id="api-show-protected">-->
                        <!--Protected-->
                    <!--</label>-->
            
                    <!--<label for="api-show-private">-->
                        <!--<input type="checkbox" id="api-show-private">-->
                        <!--Private-->
                    <!--</label>-->
                    <!--<label for="api-show-deprecated">-->
                        <!--<input type="checkbox" id="api-show-deprecated">-->
                        <!--Deprecated-->
                    <!--</label>-->
            
                <!--</div>-->
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/_renderer/renderer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function () {

    &quot;use strict&quot;;

    const LEN_CHUNKS = 12;

    xeogl.renderer = xeogl.renderer || {};

    xeogl.renderer.Renderer = function (stats, canvas, gl, options) {

        options = options || {};

        this.stats = stats || {};

        this.gl = gl;
        this.canvas = canvas;

        this._programFactory = new xeogl.renderer.ProgramFactory(this.stats, gl);
        this._objectFactory = new xeogl.renderer.ObjectFactory();
        this._chunkFactory = new xeogl.renderer.ChunkFactory();

        this._shadowLightObjects = {}; // WIP: Objects for each light that has a shadow

        // Indicates if the canvas is transparent
        this.transparent = options.transparent === true;

        /**
         * Optional callback to fire when renderer wants to
         * bind an output framebuffer. This is useful when we need to bind a stereo output buffer for WebVR.
         *
         * When this is missing, the renderer will implicitly bind
         * WebGL&#x27;s default framebuffer.
         *
         * The callback takes one parameter, which is the index of the current
         * rendering pass in which the buffer is to be bound.
         *
         * Use like this: myRenderer.bindOutputFramebuffer = function(pass) { .. });
         */
        this.bindOutputFramebuffer = null;

        /**
         * Optional callback to fire when renderer wants to
         * unbind any output drawing framebuffer that was
         * previously bound with #bindOutputFramebuffer.
         *
         * The callback takes one parameter, which is the index of the current
         * rendering pass in which the buffer is to be bound.
         *
         * Use like this: myRenderer.unbindOutputFramebuffer = function(pass) { .. });
         *
         * Callback takes no parameters.
         */
        this.unbindOutputFramebuffer = null;

        // Objects mapped to their IDs
        this.objects = {};

        // The current ambient color, if available
        this._ambient = null;

        // The current ambient color.
        this.ambientColor = xeogl.math.vec4([0, 0, 0, 1]);

        // Objects in a list, ordered by state
        this._objectList = [];
        this._objectListLen = 0;

        // List of objects that were rendered in the last picking pass, for indexing when using color-index picking
        this._objectPickList = [];
        this._objectPickListLen = 0;

        // Shadow-&gt;Object lookup
        this._shadowObjectLists = {};

        // Render states

        this.lights = null;
        this.material = null;
        this.modelTransform = null;
        this.viewTransform = null;
        this.projTransform = null;
        this.clips = null;
        this.geometry = null;
        this.viewport = null;
        this.outline = null;
        this.xray = null;
        this.modes = null;

        // Dirty flags

        this.objectListDirty = true;
        this.stateOrderDirty = true;
        this.stateSortDirty = true;
        this.imageDirty = true;
    };

    /**
     * Reallocates WebGL resources for objects within this renderer.
     */
    xeogl.renderer.Renderer.prototype.webglRestored = function (gl) {
        this.gl = gl;
        this._programFactory.webglRestored(gl);
        this._chunkFactory.webglRestored();
        if (this._pickBuf) {
            this._pickBuf.webglRestored(gl);
        }
        this.imageDirty = true;
    };

    /**
     * Internally creates (or updates) a {@link xeogl.renderer.Object} of the given
     * ID from whatever component state cores are currently set on this {@link xeogl.Renderer}.
     * The object is created if it does not already exist in the display, otherwise
     * it is updated with the current states, possibly replacing states already
     * referenced by the object.
     *
     * @param {String} objectId ID of object to create or update
     */
    xeogl.renderer.Renderer.prototype.buildObject = function (objectId) {

        var object = this.objects[objectId];

        if (!object) {
            object = this._objectFactory.get(objectId);
            object.hash = &quot;&quot;;
        }

        object.material = this.material;
        object.geometry = this.geometry;
        object.viewport = this.viewport;
        object.lights = this.lights;
        object.outline = this.outline;
        object.xray = this.xray;
        object.modes = this.modes;

        // Build hash of the object&#x27;s state configuration. This is used
        // to hash the object&#x27;s shader so that it may be reused by other
        // objects that have the same state configuration.

        var hash = ([
            this.geometry.hash,
            this.clips.hash,
            this.material.hash,
            this.lights.hash,
            this.modes.hash
        ]).join(&quot;;&quot;);

        if (hash !== object.hash) {

            // Get new program for object

            if (object.program) {
                this._programFactory.put(object.program);
            }

            object.program = this._programFactory.get(hash, this);
            object.hash = hash;

            // Handle shader error

            var programState = object.program;
            if (programState) {
                var program = programState.program;
                if (!program.allocated || !program.compiled || !program.validated || !program.linked) {
                    if (this.objects[objectId]) {
                        this.removeObject(objectId); // Don&#x27;t keep faulty objects in the renderer
                    }
                    return {
                        error: true,
                        errorLog: program.errorLog
                    }
                }
            }
        }

        this._setChunk(object, 0, &quot;program&quot;, object.program); // Must be first
        this._setChunk(object, 1, &quot;modes&quot;, this.modes);
        this._setChunk(object, 2, &quot;modelTransform&quot;, this.modelTransform);
        this._setChunk(object, 3, &quot;viewTransform&quot;, this.viewTransform);
        this._setChunk(object, 4, &quot;projTransform&quot;, this.projTransform);
        this._setChunk(object, 5, &quot;lights&quot;, this.lights);
        this._setChunk(object, 6, this.material.type, this.material); // Supports different material systems
        this._setChunk(object, 7, &quot;clips&quot;, this.clips);
        this._setChunk(object, 8, &quot;viewport&quot;, this.viewport);
        this._setChunk(object, 9, &quot;outline&quot;, this.outline);
        this._setChunk(object, 10, &quot;xray&quot;, this.xray);
        this._setChunk(object, 11, &quot;geometry&quot;, this.geometry);
        this._setChunk(object, 12, &quot;draw&quot;, this.geometry, true); // Must be last

        // Ambient light is global across everything in display, and
        // can never be disabled, so grab it now because we want to
        // feed it to gl.clearColor before each display list render

        // Also grab the first spotlight we get, because we&#x27;ll use that to cast shadows

        this._setAmbientLights(this.lights);

        if (!this.objects[objectId]) {
            this.objects[objectId] = object;
            this.objectListDirty = true;
        } else {
            this.stateOrderDirty = true;
        }

        object.compiled = true;

        return object;
    };

    xeogl.renderer.Renderer.prototype._mapShadowLightObject = function (lights, object) {
        var shadow;
        var objects;
        for (var i = 0, len = lights.length; i &lt; len; i++) {
            shadow = lights[i].shadow;
            if (shadow) {
                objects = (this._shadowLightObjects[shadow.id] || (this._shadowLightObjects[shadow.id] = {}));
                objects[object.id] = object;
            }
        }
    };

    xeogl.renderer.Renderer.prototype._setChunk = function (object, chunkIndex, type, state, neg) {
        var id;
        var chunkType = this._chunkFactory.types[type];
        if (type === &quot;program&quot;) {
            id = (object.program.id + 1) * 100000000;
        } else if (chunkType.constructor.prototype.programGlobal) {
            id = state.id;
        } else {
            id = ((object.program.id + 1) * 100000000) + ((state.id + 1));
        }
        if (neg) { // &lt;&lt;--------------- What&#x27;s this for?
            id *= 100000;
        }
        var oldChunk = object.chunks[chunkIndex];
        if (oldChunk) {
            this._chunkFactory.putChunk(oldChunk);
        }
        object.chunks[chunkIndex] = this._chunkFactory.getChunk(id, type, object.program.program, state);
    };

    xeogl.renderer.Renderer.prototype._setAmbientLights = function (state) {
        var lights = state.lights;
        var light;
        for (var i = 0, len = lights.length; i &lt; len; i++) {
            light = lights[i];
            if (light.type === &quot;ambient&quot;) {
                this._ambient = light;
            }
        }
    };

    xeogl.renderer.Renderer.prototype.removeObject = function (objectId) {
        var object = this.objects[objectId];
        if (!object) {
            return;
        }
        var chunks = object.chunks;
        for (var i = 0, len = chunks.length; i &lt; len; i++) {
            this._chunkFactory.putChunk(chunks[i]);
            chunks[i] = null;
        }
        this._programFactory.put(object.program);
        object.program = null;
        object.hash = null;
        this._objectFactory.put(object);
        delete this.objects[objectId];
        this.objectListDirty = true;
    };

    xeogl.renderer.Renderer.prototype.render = function (params) {
        params = params || {};
        this._update();
        if (this.imageDirty || params.force) {
            if (xeogl.WEBGL_INFO.SUPPORTED_EXTENSIONS[&quot;OES_element_index_uint&quot;]) { // In case context lost/recovered
                this.gl.getExtension(&quot;OES_element_index_uint&quot;);
            }
            this._drawShadowMap();
            this._drawObjects(params);
            this.stats.frame.frameCount++;
            this.imageDirty = false;
        }
    };

    xeogl.renderer.Renderer.prototype._update = function () {
        if (this.objectListDirty) {
            this._buildObjectList();
            this.objectListDirty = false;
            this.stateOrderDirty = true;
        }
        if (this.stateOrderDirty) {
            this._makeStateSortKeys();
            this.stateOrderDirty = false;
            this.stateSortDirty = true;
        }
        if (this.stateSortDirty) {
            this._stateSort();
            this._buildShadowObjectLists();
            this.stateSortDirty = false;
            this.imageDirty = true;
        }
    };

    xeogl.renderer.Renderer.prototype._buildObjectList = function () {
        this._objectListLen = 0;
        for (var objectId in this.objects) {
            if (this.objects.hasOwnProperty(objectId)) {
                this._objectList[this._objectListLen++] = this.objects[objectId];
            }
        }
        for (var i = this._objectListLen, len = this._objectList.length; i &lt; len; i++) {
            this._objectList[i] = null; // Release memory
        }
        this._objectList.length = this._objectListLen;
    };

    xeogl.renderer.Renderer.prototype._makeStateSortKeys = function () {
        var object;
        for (var i = 0, len = this._objectListLen; i &lt; len; i++) {
            object = this._objectList[i];
            if (!object.program) { // Non-visual object (eg. sound)
                object.sortKey = -1;
            } else {
                object.sortKey =
                    +((object.modes.layer + 1) * 10000000000000)
                    + ((object.program.id + 1) * 100000000)
                    + ((object.material.id + 1) * 10000)
                    + object.geometry.id;
            }
        }
    };

    xeogl.renderer.Renderer.prototype._stateSort = function () {
        this._objectList.length = this._objectListLen;
        this._objectList.sort(function (a, b) {
            return a.sortKey - b.sortKey;
        });
    };

    xeogl.renderer.Renderer.prototype._buildShadowObjectLists = function () {
        var i;
        var len;
        var object;
        var j;
        var lenj;
        var lights;
        var light;
        var shadowObjectList;
        this._shadowObjectLists = {}; // TODO: Optimize for GC
        for (i = 0, len = this._objectListLen; i &lt; len; i++) {
            object = this._objectList[i];
            if (!object.compiled || !object.modes.castShadow || object.modes.visible) {
                continue;
            }
            lights = object.lights.lights;
            for (j = 0, lenj = lights.length; j &lt; lenj; j++) {
                light = lights[j];
                if (!light.shadow) {
                    continue;
                }
                shadowObjectList = this._shadowObjectLists[light.id];
                if (!shadowObjectList) {
                    shadowObjectList = this._shadowObjectLists[light.id] = {
                        light: light,
                        objects: []
                    };
                }
                shadowObjectList.objects.push(object);
            }
        }
    };

    xeogl.renderer.Renderer.prototype._drawShadowMap = function () {
        var lightId;
        var shadowObjectLists = this._shadowObjectLists;
        var shadowObjectList;
        var light;
        for (lightId in shadowObjectLists) {
            if (shadowObjectLists.hasOwnProperty(lightId)) {
                shadowObjectList = shadowObjectLists[lightId];
                light = shadowObjectList.light;
                //   if (light.shadowDirty) {
                this._drawLightShadows(light, shadowObjectList.objects);
                //   }
            }
        }
    };

    xeogl.renderer.Renderer.prototype._drawLightShadows = (function () {

        var frameCtx = {};
        var lastChunkId = new Int32Array(LEN_CHUNKS);

        function clearStateTracking() {
            for (var i = 0; i &lt; LEN_CHUNKS; i++) {
                lastChunkId[i] = null;
            }
        }

        function drawObjectShadow(frameCtx, object) {
            var chunks = object.chunks;
            var chunk;
            for (var i = 0, len = chunks.length; i &lt; len; i++) {
                chunk = chunks[i];
                if (chunk) {
                    if (chunk.shadow &amp;&amp; (chunk.unique || lastChunkId[i] !== chunk.id)) {
                        chunk.shadow(frameCtx);
                        lastChunkId[i] = chunk.id;
                    }
                }
            }
        }

        return function (light, objects) {

            var shadow = light.shadow;

            if (!shadow) {
                return;
            }

            var renderBuf = light.getShadowRenderBuf();

            if (!renderBuf) {
                return;
            }

            renderBuf.bind();
            renderBuf.clear();

            frameCtx.backfaces = true;
            frameCtx.frontface = true;
            frameCtx.drawElements = 0;
            frameCtx.useProgram = 0;
            frameCtx.shadowViewMatrix = light.getShadowViewMatrix();
            frameCtx.shadowProjMatrix = light.getShadowProjMatrix();

            var gl = this.gl;

            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.BLEND);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            var i;
            var len;
            var object;

            clearStateTracking();

            for (i = 0, len = objects.length; i &lt; len; i++) {
                object = objects[i];
                if (!object.compiled || !object.modes.visible) {
                    continue; // For now, culled objects still cast shadows
                }
                drawObjectShadow(frameCtx, object);
            }

            gl.finish();

            renderBuf.unbind();
        };
    })();

    xeogl.renderer.Renderer.prototype._drawObjects = (function () {

        var outlinedObjects = [];
        var transparentObjects = [];
        var numTransparentObjects = 0;

        var lastChunkId = new Int32Array(LEN_CHUNKS);

        var frameCtx = {};

        function clearStateTracking() {
            for (var i = 0; i &lt; LEN_CHUNKS; i++) {
                lastChunkId[i] = null;
            }
        }

        function drawObject(frameCtx, object) {
            var chunks = object.chunks;
            var chunk;
            for (var i = 0, len = chunks.length; i &lt; len; i++) {
                chunk = chunks[i];
                if (chunk) {
                    if (chunk.draw &amp;&amp; (chunk.unique || lastChunkId[i] !== chunk.id)) {
                        chunk.draw(frameCtx);
                        lastChunkId[i] = chunk.id;
                    }
                }
            }
        }

        function drawObjectOutline(frameCtx, object) {
            var chunks = object.chunks;
            var chunk;
            for (var i = 0, len = chunks.length; i &lt; len; i++) {
                chunk = chunks[i];
                if (chunk) {
                    if (chunk.outline &amp;&amp; (chunk.unique || lastChunkId[i] !== chunk.id)) {
                        chunk.outline(frameCtx);
                        lastChunkId[i] = chunk.id;
                    }
                }
            }
        }

        return function (params) {

            var gl = this.gl;

            var ambient = this._ambient;
            if (ambient) {
                var color = ambient.color;
                var intensity = ambient.intensity;
                this.ambientColor[0] = color[0] * intensity;
                this.ambientColor[1] = color[1] * intensity;
                this.ambientColor[2] = color[2] * intensity;
            } else {
                this.ambientColor[0] = 0;
                this.ambientColor[1] = 0;
                this.ambientColor[2] = 0;
            }

            frameCtx.backfaces = false;
            frameCtx.frontface = true; // true == &quot;ccw&quot; else &quot;cw&quot;
            frameCtx.textureUnit = 0;
            frameCtx.ambientColor = this.ambientColor;
            frameCtx.drawElements = 0;
            frameCtx.useProgram = 0;
            frameCtx.bindTexture = 0;
            frameCtx.bindArray = 0;
            frameCtx.pass = params.pass;

            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

            if (this.transparent) { // Canvas is transparent
                gl.clearColor(0, 0, 0, 0);
            } else {
                gl.clearColor(this.ambientColor[0], this.ambientColor[1], this.ambientColor[2], 1.0);
            }

            gl.enable(gl.DEPTH_TEST);
            gl.frontFace(gl.CCW);
            gl.enable(gl.CULL_FACE);
            gl.depthMask(true);

            var i;
            var len;
            var object;

            var startTime = (new Date()).getTime();

            if (this.bindOutputFramebuffer) {
                this.bindOutputFramebuffer(params.pass);
            }

            if (params.clear !== false) {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            }

            // Render opaque, non-outlined objects

            var numOutlinedObjects = 0;

            numTransparentObjects = 0;

            clearStateTracking();

            for (i = 0, len = this._objectListLen; i &lt; len; i++) {
                object = this._objectList[i];
                if (!object.compiled || object.modes.culled === true || object.modes.visible === false) {
                    continue;
                }
                if (object.material.alphaMode === 2 /* blend */  || object.modes.xray) {
                    transparentObjects[numTransparentObjects++] = object;
                    continue;
                }
                if (object.modes.outlined) {
                    outlinedObjects[numOutlinedObjects++] = object;
                    continue;
                }
                drawObject(frameCtx, object);
            }

            // Render opaque outlined objects

            if (numOutlinedObjects &gt; 0) {

                // Render objects

                gl.enable(gl.STENCIL_TEST);
                gl.stencilFunc(gl.ALWAYS, 1, 1);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
                gl.stencilMask(1);
                gl.clearStencil(0);
                gl.clear(gl.STENCIL_BUFFER_BIT);

                clearStateTracking();

                for (i = 0; i &lt; numOutlinedObjects; i++) {
                    drawObject(frameCtx, outlinedObjects[i]);
                }

                // Render outlines

                gl.stencilFunc(gl.EQUAL, 0, 1);
                gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                gl.stencilMask(0x00);
                gl.disable(gl.CULL_FACE); // Need both faces for better corners with face-aligned normals

                clearStateTracking();

                for (i = 0; i &lt; numOutlinedObjects; i++) {
                    drawObjectOutline(frameCtx, outlinedObjects[i]);
                }

                gl.disable(gl.STENCIL_TEST);
            }

            // Draw transparent objects

            var blendType = true;
            var transparentDepthMask = true;

            if (numTransparentObjects &gt; 0) {

                gl.enable(gl.CULL_FACE);
                gl.enable(gl.BLEND);

                frameCtx.backfaces = false;

                if (!transparentDepthMask) {
                    gl.depthMask(false);
                }

                if (blendType) {

                    // Makes glTF windows appear correct
                     gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                } else {

                    gl.blendEquation(gl.FUNC_ADD);
                    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                }

                //gl.colorMask(true, true, true, true);

                numOutlinedObjects = 0;

                clearStateTracking();

                for (i = 0; i &lt; numTransparentObjects; i++) {
                    object = transparentObjects[i];
                    if (object.modes.outlined) {
                        outlinedObjects[numOutlinedObjects++] = object; // Build outlined list
                        continue;
                    }
                    drawObject(frameCtx, object);
                }

                // Transparent outlined objects are not supported yet

                gl.disable(gl.BLEND);
                //gl.colorMask(true, true, true, false);
            }

            var endTime = Date.now();
            var frameStats = this.stats.frame;

            frameStats.renderTime = (endTime - startTime) / 1000.0;
            frameStats.drawElements = frameCtx.drawElements;
            frameStats.useProgram = frameCtx.useProgram;
            frameStats.bindTexture = frameCtx.bindTexture;
            frameStats.bindArray = frameCtx.bindArray;

            var numTextureUnits = xeogl.WEBGL_INFO.MAX_TEXTURE_IMAGE_UNITS;
            for (var ii = 0; ii &lt; numTextureUnits; ii++) {
                gl.activeTexture(gl.TEXTURE0 + ii);
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }

            if (this.unbindOutputFramebuffer) {
                this.unbindOutputFramebuffer(params.pass);
            }
        };
    })();

    /**
     * Attempts to pick an object.
     */
    xeogl.renderer.Renderer.prototype.pick = (function () {

        var math = xeogl.math;

        var tempVec3a = math.vec3();
        var tempMat4a = math.mat4();
        var up = math.vec3([0, 1, 0]);
        var pickFrustumMatrix = math.frustumMat4(-1, 1, -1, 1, 0.1, 10000);

        return function (params) {

            var hit = null;

            this._update();

            if (xeogl.WEBGL_INFO.SUPPORTED_EXTENSIONS[&quot;OES_element_index_uint&quot;]) { // In case context lost/recovered
                this.gl.getExtension(&quot;OES_element_index_uint&quot;);
            }

            var pickBuf = this._pickBuf || (this._pickBuf = new xeogl.renderer.webgl.RenderBuffer(this.canvas, this.gl));

            pickBuf.bind();
            pickBuf.clear();

            var pickBufX;
            var pickBufY;
            var origin;
            var direction;
            var look;
            var pickViewMatrix = null;
            var pickProjMatrix = null;

            if (!params.canvasPos) { // Ray-picking with arbitrarily World-space ray

                origin = params.origin || math.vec3([0, 0, 0]);
                direction = params.direction || math.vec3([0, 0, 1]);
                look = math.addVec3(origin, direction, tempVec3a);

                pickViewMatrix = math.lookAtMat4v(origin, look, up, tempMat4a);
                pickProjMatrix = pickFrustumMatrix;

                pickBufX = this.canvas.clientWidth * 0.5;
                pickBufY = this.canvas.clientHeight * 0.5;

            } else {

                if (params.canvasPos) {
                    pickBufX = params.canvasPos[0];
                    pickBufY = params.canvasPos[1];

                } else {
                    pickBufX = this.canvas.clientWidth * 0.5;
                    pickBufY = this.canvas.clientHeight * 0.5;
                }
            }

            this._pickObjectPass(pickViewMatrix, pickProjMatrix);

            // Convert picked pixel color to object index

            var pix = pickBuf.read(pickBufX, pickBufY);
            var pickedObjectIndex = pix[0] + pix[1] * 256 + pix[2] * 65536;
            pickedObjectIndex = (pickedObjectIndex &gt;= 1) ? pickedObjectIndex - 1 : -1;

            var object = this._objectPickList[pickedObjectIndex];

            if (object) { // Object picked

                hit = {
                    entity: object.id
                };

                if (params.pickSurface) { // Now do a primitive-pick if requested

                    pickBuf.clear();

                    this._pickPrimitivePass(object, pickViewMatrix, pickProjMatrix);

                    this.gl.finish();

                    // Convert picked pixel color to primitive index

                    pix = pickBuf.read(pickBufX, pickBufY);
                    var primIndex = pix[0] + (pix[1] * 256) + (pix[2] * 256 * 256) + (pix[3] * 256 * 256 * 256);
                    primIndex *= 3; // Convert from triangle number to first vertex in indices

                    hit.primIndex = primIndex;

                    if (pickViewMatrix) {
                        hit.origin = origin;
                        hit.direction = direction;
                    }
                }
            }

            pickBuf.unbind();

            return hit;
        };
    })();


    xeogl.renderer.Renderer.prototype._pickObjectPass = (function () {

        var frameCtx = {};

        var lastChunkId = new Int32Array(LEN_CHUNKS);

        function clearStateTracking() {
            for (var i = 0; i &lt; LEN_CHUNKS; i++) {
                lastChunkId[i] = null;
            }
        }

        function pickObject(frameCtx, object) {
            var chunks = object.chunks;
            var chunk;
            for (var i = 0, len = chunks.length; i &lt; len; i++) {
                chunk = chunks[i];
                if (chunk) {
                    if (chunk.pickObject &amp;&amp; (chunk.unique || lastChunkId[i] !== chunk.id)) {
                        chunk.pickObject(frameCtx);
                        lastChunkId[i] = chunk.id;
                    }
                }
            }
        }

        return function (pickViewMatrix, pickProjMatrix) {

            frameCtx.backfaces = true;
            frameCtx.frontface = true; // true == &quot;ccw&quot; else &quot;cw&quot;
            frameCtx.pickViewMatrix = pickViewMatrix;
            frameCtx.pickProjMatrix = pickProjMatrix;
            frameCtx.pickObjectIndex = 0;

            var gl = this.gl;

            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.clearColor(0, 0, 0, 0);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            clearStateTracking();

            this._objectPickListLen = 0;

            var i;
            var len;
            var object;

            for (i = 0, len = this._objectListLen; i &lt; len; i++) {
                object = this._objectList[i];
                if (!object.compiled || object.modes.culled === true || object.modes.visible === false || object.modes.pickable === false) {
                    continue;
                }
                this._objectPickList[this._objectPickListLen++] = object;
                pickObject(frameCtx, object);
            }
        };
    })();

    xeogl.renderer.Renderer.prototype._pickPrimitivePass = (function () {

        var frameCtx = {};

        return function (object, pickViewMatrix, pickProjMatrix) {

            frameCtx.backfaces = true;
            frameCtx.frontface = true; // true == &quot;ccw&quot; else &quot;cw&quot;
            frameCtx.pickViewMatrix = pickViewMatrix;
            frameCtx.pickProjMatrix = pickProjMatrix;

            var gl = this.gl;

            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.clearColor(0, 0, 0, 0);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            var i;
            var len;
            var chunks;
            var chunk;

            chunks = object.chunks;
            for (i = 0, len = chunks.length; i &lt; len; i++) {
                chunk = chunks[i];
                if (chunk.pickPrimitive) {
                    chunk.pickPrimitive(frameCtx);
                }
            }
        };
    })();

    /**
     * Reads the colors of some pixels in the current image.
     */
    xeogl.renderer.Renderer.prototype.readPixels = function (pixels, colors, len, opaqueOnly) {
        var renderBuf = this._readPixelBuf || (this._readPixelBuf = new xeogl.renderer.webgl.RenderBuffer(this.canvas, this.gl));
        renderBuf.bind();
        renderBuf.clear();
        this.render({
            force: true,
            opaqueOnly: opaqueOnly
        });
        var color;
        var i;
        var j;
        var k;
        for (i = 0; i &lt; len; i++) {
            j = i * 2;
            k = i * 4;
            color = renderBuf.read(pixels[j], pixels[j + 1]);
            colors[k] = color[0];
            colors[k + 1] = color[1];
            colors[k + 2] = color[2];
            colors[k + 3] = color[3];
        }
        renderBuf.unbind();
        this.imageDirty = true;
    };

    xeogl.renderer.Renderer.prototype.destroy = function () {
        this._programFactory.destroy();
        if (this._pickBuf) {
            this._pickBuf.destroy();
        }
        if (this._readPixelBuf) {
            this._readPixelBuf.destroy();
        }
    };
})();

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
